{"/apis":{"title":"Introduction","data":{"":"Mintscan API, integral to Mintscan 2.0, stems from enterprise-grade onchain data indexing. Through features like tx builder and historical statistics APIs, it offers easy access to dynamic onchain data, including account balances and staking APR. Streamlining raw data processing, Mintscan API simplifies Interchain dapp development, positioning itself as a key piece in the Interchain infrastructure puzzle.For inquery, please contact us api@cosmostation.io","how-to-get-api-key#How to get API Key?":"Get start sign upCurrently in beta, approval is being processed via email(api@cosmostation.io).","features#Features":"RPC Endpoint\nHistorical API\nProto Builder API\nStatistics API\nUtility API\nCustom API\nSearch API","supported-chain-list#Supported chain list":"Akash\nArchway\nCosmos\nCelestia\ndYdX\nEvmos\nInjective\nJuno\nKava\nNeutron\nOsmosis\nStride","api-reference#API Reference":"Type\tAPI\tCredit\tProxy API\tLCD Proxy\t1\tCustom API\tAccount\t5\tStatistics API\tTransaction Statistics\t3\t\tMessage Statistics\t3\tBuilder API\tTransaction Builder\t5 ~ 10\tHistorical API\tAccount Transactions\t5\t\tAccount Votes\t5\t\tAccount Balance History\t7\t\tRichlist\t10\t\tValidator Votes\t5\t\tValidator Commission History\t5\t\tValidator Delegators\t10\t\tValidator Block Sign\t3\t\tValidator Voting Power\t3\t\tValidator Proposed Blocks\t3\t\tTransactions Data By Hash\t5\tUtility API\tNode Info\t5\t\tInflation\t3\t\tStaking APR\t5\t\tAssets\t3\t\tPrices\t3 ~ 5\tSearch API\tSearch Transaction By Hash\t10"}},"/apis/reference/builder/tx-builder/make-signature":{"title":"How Make Signature","data":{"":"This documentation page provides an example of generating a signature using the tx (SignDoc) produced in the Build Transaction process.\nThe example code in this document is written in Node.js. Users can implement the sign logic based on their respective programming language.\n// Import packages for sign\nimport * as TinySecp256k1 from 'tiny-secp256k1';\nimport * as encHex from 'crypto-js/enc-hex';\nimport * as sha256 from 'crypto-js/sha256';\n// Define a custom function to execute the logic described on the Build Transaction page.\n// Each user can implement their own version of this function and use it accordingly\nconst buildResult = await buildTx();\n/* Example of result\n {\n  \"tx\": \"\",\n  \"messages\": [\n    {\n      \"type\": \"cosmos.staking.v1beta1.MsgDelegate\",\n      \"delegatorAddress\": \"osmo1gr0e3pj3y6fqvzyam0qxyw9h5dwfrvh8zv3x9p\",\n      \"validatorAddress\": \"\",\n      \"amount\": { \"denom\": \"uosmo\", \"amount\": \"1\" }\n    }\n  ],\n  \"fee\": { \"amount\": [{ \"denom\": \"uosmo\", \"amount\": \"760\" }], \"gas\": \"303815\" },\n  \"publicKey\": {\n    \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n    \"key\": \"A00Jvfv1luvAODaiOPIMZpDTWSq7qvoFV8k7ptdsDqLU\"\n  },\n  \"accountNumber\": \"63277\",\n  \"sequence\": \"12\"\n}\n*/\n// Removes the '0x' string from the beginning of the tx.\nconst signDoc = buildResult.tx.replace(/^0x(.*)/, '$1');\n// SignDoc Example: \n// The part that creates a Buffer using the user's Private Key.\n// If the Private Key starts with '0x', the '0x' prefix is removed and the value is used.\nconst privateKey = Buffer.from(\n  '',\n  'hex',\n);\nconst hashedSignDoc = sha256(encHex.parse(signDoc)).toString(encHex);\nconst signResult = TinySecp256k1.sign(Buffer.from(hashedSignDoc, 'hex'), privateKey);\nconst signatureHex = Buffer.from(signResult).toString('hex');\n// Use this to broadcast the transaction\nconst signature = `0x${signatureHex}`;\n// Example: "}},"/apis/reference/builder/tx-builder/build":{"title":"Build Transactions","data":{"post-v1networktx-builder#[POST] /v1/:network/tx-builder":"This API returns the SignDoc data for broadcasting transactions.\nThe response includes tx for generating the signature, original messages used to create the SignDoc, fee value, and basic information of the account.\nUsers can either generate the signature directly without 0x from the value and broadcast it, or use the provided broadcast API to send the tx.\nMulti sign account is not supported yet.","request#Request":"Authorization: Bearer {access_token}\nContent-Type: application/json","response#Response":"{\n  // SignDoc for generating the signature. Use the data without '0x'\n  \"tx\": \"\",\n  // Original data that user transfer\n  \"messages\": [\n    {\n      \"type\": \"cosmos.staking.v1beta1.MsgDelegate\",\n      \"delegatorAddress\": \"osmo1gr0e3pj3y6fqvzyam0qxyw9h5dwfrvh8zv3x9p\",\n      \"validatorAddress\": \"\",\n      \"amount\": { \"denom\": \"uosmo\", \"amount\": \"1\" }\n    }\n  ],\n  // Transaction fee\n  \"fee\": { \"amount\": [{ \"denom\": \"uosmo\", \"amount\": \"760\" }], \"gas\": \"303815\" },\n  // Account public key of signer\n  \"publicKey\": {\n    \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n    \"key\": \"A00Jvfv1luvAODaiOPIMZpDTWSq7qvoFV8k7ptdsDqLU\"\n  },\n  // Account number of signer\n  \"accountNumber\": \"63277\",\n  // Account sequence of signer\n  \"sequence\": \"12\"\n}","how-to-make-a-public-key-from-private-key#How to make a public key from private key":"const privateKey = Buffer.from(\n  '',\n  'hex',\n);\nconst pubKeyUint8Array = TinySecp256k1.pointFromScalar(privateKey, true);\nif (!pubKeyUint8Array) {\n  throw new Error('Invalid private key');\n}\n// Use this publicKey when sending a transaction (tx) for the first time.\nconst publicKey = Buffer.from(pubKeyUint8Array).toString('base64');","send-transaction#Send Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{\"type\": \"string\", \"key\": \"string\"}],\n  // Message Array\n  \"messages\": [\n    {\n      // Message Type\n      \"type\": \"cosmos.bank.v1beta1.MsgSend\",\n      // Sender Address\n      \"fromAddress\": \"string\",\n      // Receiver Address\n      \"toAddress\": \"string\",\n      // Amount Array\n      \"amount\": [\n        {\n          \"denom\": \"string\",\n          \"amount\"\": string\"\n        }\n      ]\n    }\n  ]\n}","delegate-transaction#Delegate Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{\"type\": \"string\", \"key\": \"string\"}],\n  // Message Array\n  \"messages\": [\n    {\n      // Message Type\n      \"type\": \"cosmos.staking.v1beta1.MsgDelegate\",\n      // Sender Address\n      \"delegatorAddress\": \"string\",\n      // Validator Address to delegate\n      \"validatorAddress\": \"string\",\n      // Amount\n      \"amount\": {\n        \"denom\": \"string\",\n        \"amount\"\": string\"\n      }\n    }\n  ]\n}","undelegate-transaction#Undelegate Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{\"type\": \"string\", \"key\": \"string\"}],\n  // Message Array\n  \"messages\": [\n    {\n      // Message Type\n      \"type\": \"cosmos.staking.v1beta1.MsgUndelegate\",\n      // Sender Address\n      \"delegatorAddress\": \"string\",\n      // Validator Address to undelegate\n      \"validatorAddress\": \"string\",\n      // Amount\n      \"amount\": {\n        \"denom\": \"string\",\n        \"amount\"\": string\"\n      }\n    }\n  ]\n}","begin-redelegate-transaction#Begin Redelegate Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{\"type\": \"string\", \"key\": \"string\"}],\n  // Message Array\n  \"messages\": [\n    {\n      // Message Type\n      \"type\": \"cosmos.staking.v1beta1.MsgBeginRedelegate\",\n      // Sender Address\n      \"delegatorAddress\": \"string\",\n      // From Validator Address to redelegate\n      \"validatorSrcAddress\": \"string\",\n      // To Validator Address to redelegate\n      \"validatorDstAddress\": \"string\",\n      // Amount\n      \"amount\": {\n        \"denom\": \"string\",\n        \"amount\"\": string\"\n      }\n    }\n  ]\n}","claim-delegate-rewards-transaction#Claim Delegate Rewards Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{\"type\": \"string\", \"key\": \"string\"}],\n  // Message Array\n  \"messages\": [\n    {\n      // Message Type\n      \"type\": \"cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\",\n      // Sender Address\n      \"delegatorAddress\": \"string\",\n      // Validator Address to claim rewards\n      \"validatorAddress\"\": string\"\n    }\n  ]\n}","claim-validator-commissions-transaction#Claim Validator Commissions Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{\"type\": \"string\", \"key\": \"string\"}],\n  // Message Array\n  \"messages\": [\n    {\n      // Message Type\n      \"type\": \"cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission\",\n      // Validator Address to withdraw validator commission\n      \"validatorAddress\"\": string\"\n    }\n  ]\n}","governance-vote-transaction#Governance Vote Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{\"type\": \"string\", \"key\": \"string\"}],\n  // Message Array\n  \"messages\": [\n    {\n      // Message Type\n      \"type\": \"cosmos.gov.v1beta1.MsgVote\",\n      // Proposal ID\n      \"proposalId\": \"string\",\n      // Voter\n      \"voter\": \"string\",\n      // Vote Option(\"VOTE_OPTION_UNSPECIFIED\" | \"VOTE_OPTION_YES\" | \"VOTE_OPTION_ABSTAIN\" | \"VOTE_OPTION_NO\" | \"VOTE_OPTION_NO_WITH_VETO\")\n      \"option\"\": string\"\n    }\n  ]\n}","wasm-contract-execute-transaction#Wasm Contract Execute Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{ \"type\": \"string\", \"key\": \"string\" }],\n  // Message Array\n  \"messages\": [\n    {\n      // Message Type\n      \"type\": \"cosmwasm.wasm.v1.MsgExecuteContract\",\n      // Sender\n      \"sender\": \"string\",\n      // Contract Address\n      \"contract\": \"string\",\n      // Execute Messages\n      \"msg\": {},\n      // Funds\n      \"funds\": []\n    }\n  ]\n}","authz-grant-transaction#Authz Grant Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{ \"type\": \"string\", \"key\": \"string\" }],\n  // Message Array\n  \"messages\": [\n    {\n      // GeneraicAuthorization\n      \"type\": \"cosmos.authz.v1beta1.MsgGrant\",\n      \"granter\": \"string\",\n      \"grantee\": \"string\",\n      \"grant\": {\n        \"authorization\": {\n          // Auth Type(\"GenericAuthorization\" | \"StakeAuthorization\" | \"SendAuthorization\")\n          \"type\": \"GenericAuthorization\",\n          \"msg\": \"string\"\n        },\n        \"expiration\": \"datetime\"\n      }\n    },\n    {\n      // StakeAuthorization\n      \"type\": \"cosmos.authz.v1beta1.MsgGrant\",\n      \"granter\": \"string\",\n      \"grantee\": \"string\",\n      \"grant\": {\n        \"authorization\": {\n          // Auth Type(\"GenericAuthorization\" | \"StakeAuthorization\" | \"SendAuthorization\")\n          \"type\": \"StakeAuthorization\",\n          \"maxTokens\": { \"denom\": \"string\", \"amount\": \"string\" },\n          // When used in conjunction with a denyList, the allowList is not applied\n          \"allowList\": { \"address\": [\"string\"] },\n          \"denyList\": { \"address\": [\"string\"] },\n          // Authorization Type(\"AUTHORIZATION_TYPE_DELEGATE\" | \"AUTHORIZATION_TYPE_UNDELEGATE\" | \"AUTHORIZATION_TYPE_REDELEGATE\")\n          \"authorizationType\": \"string\"\n        },\n        \"expiration\": \"datetime\"\n      }\n    },\n    {\n      // SendAuthorization\n      \"type\": \"cosmos.authz.v1beta1.MsgGrant\",\n      \"granter\": \"string\",\n      \"grantee\": \"string\",\n      \"grant\": {\n        \"authorization\": {\n          // Auth Type(\"GenericAuthorization\" | \"StakeAuthorization\" | \"SendAuthorization\")\n          \"type\": \"SendAuthorization\",\n          \"spendLimit\": [{ \"denom\": \"string\", \"amount\": \"string\" }]\n        },\n        \"expiration\": \"datetime\"\n      }\n    }\n  ]\n}","authz-execute-transaction#Authz Execute Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{ \"type\": \"string\", \"key\": \"string\" }],\n  // Message Array\n  \"messages\": [\n    {\n      \"type\": \"cosmos.authz.v1beta1.MsgExec\",\n      \"grantee\": \"string\",\n      \"msgs\": [\n        {\n          // type_url excluding '/' (ex: cosmos.bank.v1beta1.MsgSend)\n          \"type\": \"string\"\n          // the values included in the corresponding type message\n        }\n      ]\n    }\n  ]\n}","authz-revoke-transaction#Authz Revoke Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{ \"type\": \"string\", \"key\": \"string\" }],\n  // Message Array\n  \"messages\": [\n    {\n      \"type\": \"cosmos.authz.v1beta1.MsgRevoke\",\n      \"granter\": \"string\",\n      \"grantee\": \"string\",\n      // msgTypeUrl\n      // GenericAuthorization, you can simply use the msg value of that authorization as it is\n      // SendAuthorization, you should use /cosmos.bank.v1beta1.MsgSend\n      // StakeAuthorization, you should provide values based on the Authorization Type granted.\n      //   - AUTHORIZATION_TYPE_DELEGATE, use /cosmos.staking.v1beta1.MsgDelegate.\n      //   - AUTHORIZATION_TYPE_UNDELEGATE, use /cosmos.staking.v1beta1.MsgUndelegate\n      //   - AUTHORIZATION_TYPE_REDELEGATE, use /cosmos.staking.v1beta1.MsgBeginRedelegate\n      \"msgTypeUrl\": \"string\"\n    }\n  ]\n}","multiple-message-type-of-transaction#Multiple Message Type of Transaction":"{\n  // Signer Address\n  \"signer\": \"string\",\n  // Tx Memo\n  \"memo\": \"string\",\n  // !!! When sending a transaction (tx) for the first time, must provide the public key\n  // pubkey type (\"tendermint/PubKeySecp256k1\" | \"ethermint/PubKeyEthSecp256k1\" | \"injective/PubKeyEthSecp256k1\")\n  \"pubkey\": [{ \"type\": \"string\", \"key\": \"string\" }],\n  // Message Array\n  \"messages\": [\n    // The message types within the messages defined above\n  ]\n}"}},"/apis/reference/custom/account":{"title":"Account","data":{"get-v1networkaccountsaddress#[GET] /v1/:network/accounts/:address":"Get account information with current balances","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The address of account\n# (string, required)\naddress: cosmos1clpqr4nrk4khgkxj78fcwwh6dl3uw4ep4tgu9q"}},"/apis/reference/historical/account/account-transactions":{"title":"Account Transactions","data":{"get-v1networkaccountsaddresstransactions#[GET] /v1/:network/accounts/:address/transactions":"Get transactions of an account","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The address of account\n# (string, required)\naddress: cosmos1clpqr4nrk4khgkxj78fcwwh6dl3uw4ep4tgu9q\n# Request per page\n# (number, optional, default: 20)\ntake: 20\n# Array of strings for filtering by message type\n# (array of string, optional)\nmessageTypes[]: /cosmos.staking.v1beta1.MsgDelegate\n# Search start datetime\n# (datetime, optional)\nfromDateTime: 2023-04-20\n# Search end datetime\n# (datetime, optional)\ntoDateTime: 2023-04-21 23:59:59\n# Value of `pagination.searchAfter` from previous request for pagination\n# (string, optional)\nsearchAfter: MTY4MDUxNjI5NjAwMHwxNDczMjU5OQ=="}},"/apis/reference/builder/tx-builder/broadcast":{"title":"Broadcast Transaction","data":{"post-v1networktx-builderbroadcast#[POST] /v1/:network/tx-builder/broadcast":"","request#Request":"Authorization: Bearer {access_token}\nContent-Type: application/json\n{\n  // Original message of the tx from the result of the Build Transaction API Call\n  \"tx\": string,\n  // Generated using the user’s private key and the tx from the result of the Build Transaction API Call.\n  \"signature\": string\n}","response#Response":"{\n  \"tx_response\": {\n    \"height\": \"0\",\n    \"txhash\": \"\",\n    \"codespace\": \"\",\n    \"code\": 0,\n    \"data\": \"\",\n    \"raw_log\": \"[]\",\n    \"logs\": [],\n    \"info\": \"\",\n    \"gas_wanted\": \"0\",\n    \"gas_used\": \"0\",\n    \"tx\": null,\n    \"timestamp\": \"\",\n    \"events\": []\n  }\n}"}},"/apis/reference/historical/account/account-richlist":{"title":"Account Balance History","data":{"get-v1networkaccountsrichlistsymbol#[GET] /v1/:network/accounts/richlist/:symbol":"Get richlist for the given symbol","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# Symbol(or Denom) of the asset to be queried\n# (string, required)\nsymbol: uatom\n# Request per page\n# (number, optional, default: 20)\ntake: 20\n# Value of `pagination.searchAfter` from previous request for pagination\n# (string, optional)\nsearchAfter: MTY4OTc1NTU4NjAwMA==\n# To display detailed information of the balance\n# (boolean, optional, default: false)\ndetail: true"}},"/apis/reference/historical/account/account-balances":{"title":"Account Balance History","data":{"get-v1networkaccountsaddressbalances#[GET] /v1/:network/accounts/:address/balances":"Get balance history of an account","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The address of account\n# (string, required)\naddress: cosmos1clpqr4nrk4khgkxj78fcwwh6dl3uw4ep4tgu9q\n# Request per page\n# (number, optional, default: 20)\ntake: 20\n# Value of `pagination.searchAfter` from previous request for pagination\n# (string, optional)\nsearchAfter: MTY4OTc1NTU4NjAwMA==\n# Search start datetime\n# (datetime, optional, default: 30 days ago)\nfromDateTime: 2023-07-20\n# Search end datetime\n# (datetime, optional, default: CURRENT_TIMESTAMP)\ntoDateTime: 2023-07-21 23:59:59"}},"/apis/reference/historical/validator/validator-block-sign":{"title":"Validator Latest Block Sign","data":{"get-v1networkvalidatorsvalidatoraddresslatestuptime#[GET] /v1/:network/validators/:validatorAddress/latestUptime":"Get latest blocks signature of validator","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The address of account\n# (string, required)\nvalidatorAddress: "}},"/apis/reference/historical/account/account-votes":{"title":"Account Votes","data":{"get-v1networkaccountsaddressvotes#[GET] /v1/:network/accounts/:address/votes":"Get a list of votes of an account","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The address of account\n# (string, required)\naddress: cosmos1clpqr4nrk4khgkxj78fcwwh6dl3uw4ep4tgu9q\n# Whether to remove duplicates for the same proposal\n# (boolean, optional, default: false)\ndistinct: true"}},"/apis/reference/historical/txs/transactions-hash":{"title":"Transactions Data","data":{"get-v1networktxshash#[GET] /v1/:network/txs/:hash":"Get transactions data by querying hash","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The hash of transaction\n# (string, required)\nhash: \n# Search end datetime\n# (height, optional)\nheight: 10086235"}},"/apis/reference/historical/validator/validator-commissions":{"title":"Validator Commission Balance History","data":{"get-v1networkvalidatorsvalidatoraddresscommissions#[GET] /v1/:network/validators/:validatorAddress/commissions":"Get commission balance history of an account","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The address of account\n# (string, required)\nvalidatorAddress: \n# Request per page\n# (number, optional, default: 20)\ntake: 20\n# Value of `pagination.searchAfter` from previous request for pagination\n# (string, optional)\nsearchAfter: MTY4OTc1NTU4NjAwMA==\n# Search start datetime\n# (datetime, optional, default: 30 days ago)\nfromDateTime: 2023-07-20\n# Search end datetime\n# (datetime, optional, default: CURRENT_TIMESTAMP)\ntoDateTime: 2023-07-21 23:59:59"}},"/apis/reference/historical/validator/validator-delegators":{"title":"Validator Delegators","data":{"get-v1networkvalidatorsvalidatoraddressdelegators#[GET] /v1/:network/validators/:validatorAddress/delegators":"Get a list of richlist of a symbol","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The address of account\n# (string, required)\nvalidatorAddress: \n# Request per page\n# (number, optional, default: 20)\ntake: 10\n# Value of skip amount for pagination\n# (number, optional, default: 0)\nfrom: 20"}},"/apis/reference/historical/validator/validator-power-events":{"title":"Validator Voting Power Events","data":{"get-v1networkvalidatorsvalidatoraddresspowerevents#[GET] /v1/:network/validators/:validatorAddress/powerEvents":"Get voting power events of validator","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The address of account\n# (string, required)\nvalidatorAddress: \n# Request per page\n# (number, optional, default: 20)\ntake: 20\n# Value of `pagination.searchAfter` from previous request for pagination\n# (string, optional)\nsearchAfter: MTY4OTc1NTU4NjAwMA=="}},"/apis/reference/historical/validator/validator-proposed-blocks":{"title":"Validator Voting Power Events","data":{"get-v1networkvalidatorsvalidatoraddressproposed#[GET] /v1/:network/validators/:validatorAddress/proposed":"Get blocks proposed by the validator","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The address of account\n# (string, required)\nvalidatorAddress: \n# Request per page\n# (number, optional, default: 20)\ntake: 20\n# Value of `pagination.searchAfter` from previous request for pagination\n# (string, optional)\nsearchAfter: MTY4OTc1NTU4NjAwMA=="}},"/apis/reference/historical/validator/validator-votes":{"title":"Validator Votes","data":{"get-v1networkvalidatorsvalidatoraddresstransactions#[GET] /v1/:network/validators/:validatorAddress/transactions":"Get a list of votes of a validator","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The address of validator\n# (string, required)\nvalidatorAddress: \n# Whether to remove duplicates for the same proposal\n# (boolean, optional, default: false)\ndistinct: true"}},"/apis/reference/proxy/lcd":{"title":"LCD Proxy","data":{"":"Proxy API for making LCD requests to BlockChain Node","getpost-v1networklcd#[GET][POST] /v1/:network/lcd/*":"You can directly access the Node LCD API by referring to the Swagger or document of the Network you want to make requests to.\nHowever, please note that certain requests are blocked as they may have a negative impact on the server.","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# The url of lcd API. See details in Swagger or document of the network\n# (string, required)\n*: /cosmos/bank/v1beta1/balances/cosmos1clpqr4nrk4khgkxj78fcwwh6dl3uw4ep4tgu9q"}},"/apis/reference/statistics/messages":{"title":"Message Counts","data":{"get-v1networkstatisticsmessages#[GET] /v1/:network/statistics/messages":"Get The Number of Transactions per each message type over the last 30 days","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# Search end datetime\n# (datetime, optional, default: CURRENT_TIMESTAMP)\ntoDateTime: 2023-07-21 23:59:59"}},"/apis/reference/search/transactions/transactions-hash":{"title":"Search Transactions","data":{"get-v1searchtransactionshash#[GET] /v1/search/transactions/:hash":"Get search transactions data by querying hash","request#Request":"Authorization: Bearer {access_token}\n# The hash of transaction\n# Can use Cosmos, Evm hash both\n# (string, required)\nhash: (Cosmos type) -> \nhash: (EVM type) -> "}},"/apis/reference/statistics/transactions":{"title":"Transactions Counts","data":{"get-v1networkstatisticstxshourly#[GET] /v1/:network/statistics/txs/hourly":"Get The Number of Transactions Per Hour","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# Search end datetime\n# (datetime, optional, default: CURRENT_TIMESTAMP)\ntoDateTime: 2023-07-21 23:59:59","get-v1networkstatisticstxsdaily#[GET] /v1/:network/statistics/txs/daily":"Get The Number of Transactions Per Day","request-1#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# Search end datetime\n# (datetime, optional, default: CURRENT_TIMESTAMP)\ntoDateTime: 2023-07-21 23:59:59","get-v1networkstatisticstxsweekly#[GET] /v1/:network/statistics/txs/weekly":"Get The Number of Transactions Per Week","request-2#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# Search end datetime\n# (datetime, optional, default: CURRENT_TIMESTAMP)\ntoDateTime: 2023-07-21 23:59:59"}},"/apis/reference/utilities/assets":{"title":"Assets","data":{"get-v1networkassets#[GET] /v1/:network/assets":"Get all assets of the current chain","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos","get-v1networkassetssymbol#[GET] /v1/:network/assets/:symbol":"Get asset of specific symbol","request-1#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# Symbol of the asset to be queried\n# (string, required)\nsymbol: uatom"}},"/apis/reference/utilities/inflation":{"title":"Chain Inflation","data":{"get-v1networkinflation#[GET] /v1/:network/inflation":"Get inflation data from the chain","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos"}},"/apis/reference/utilities/staking-apr":{"title":"Chain Staking APR","data":{"get-v1networkapr#[GET] /v1/:network/apr":"Get default staking APR of the chain","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos","get-v1networkaprvalidatoraddress#[GET] /v1/:network/apr/:validatorAddress":"Get staking APR when delegating to a specific validator","request-1#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos\n# Validator address to delegate\n# (string, required)\nvalidatorAddress: "}},"/extension/guide/account/add-account":{"title":"Add Account","data":{"":"Create a new wallet, restore with an existing mnemonic phrase, or restore with a private key.","create-wallet#Create wallet":"The following process is for users who do not have a wallet and wish to create a new wallet.'Create wallet' will import a new wallet with a mnemonic phrase.\nStep 1 Click 'Create wallet'Step 2 Enter 'Account name'. Account name will be used for users to easily distinguish wallets imported on the extension.Step 3 Your mnemonic phrase will be displayed. Cosmostation Wallet Extension supports both 12 words and 24 words mnemonic phrases.\nPlease make sure to back up your mnemonic phrase and save it in a safe location only accessible by you. If the mnemonic phrase is lost, you will not be able to regain access to your account.DO NOT share your Secret Recovery Phrase with anyone! If someone has access to your secret phrase, they will have access to your wallet. Cosmostation support will NEVER ask you for your secret phrase or your private key.\nStep 4 (Optional) Choose the HD path you wish to import. Cosmostation Wallet Extension supports HD paths designated/unique to each network by default.Step 5 Enter your seed phrase in correct order. This process is to confirm that you have saved the correct mnemonic phrase.Step 6 Choose networks to display in your Cosmostation Wallet Extension. You must select at least 1 chain in order to proceed.Step 7 Enter your password for Cosmostation Wallet Extension. Password must be more than 8 characters.","restore-wallet-with-a-mnemonic-phrase#Restore wallet with a mnemonic phrase":"The following process is for users who already have a mnemonic phrase.\nStep 1 Click 'Restore with mnemonics'Step 2 Enter 'Account name' and 'Mnemonic phrases'. Account name will be used for you to easily distinguish wallets.Step 3 (Optional) Choose the HD path you wish to import. Cosmostation Wallet Extension supports HD paths designated/unique to each network by default.Step 4 Choose networks to display in your Cosmostation Wallet Extension. You must select at least 1 chain in order to proceed.Step 5 Enter your password for Cosmostation Wallet Extension. Password must be more than 8 characters.","restore-wallet-with-a-private-key#Restore wallet with a private key":"The following process is for users that already have a private key.\nStep 1 Click 'Import wallet'.Step 2 Click 'Restore with private key'.Step 3 Enter your 'Account name' and 'Private key'. (Private keys start with 0x and consists of a 66 digit string)Step 4 Choose networks to display in your Cosmostation Wallet Extension. You must select at least 1 chain in order to proceed.Step 5 Enter your password for Cosmostation Wallet Extension. Password must be more than 8 characters."}},"/apis/reference/utilities/prices":{"title":"Prices","data":{"get-v1pricessymbolcoingeckoid#[GET] /v1/prices/:symbol/coingeckoId":"Get coingecko ID via symbol","request#Request":"Authorization: Bearer {access_token}\n# Symbol of the asset to be queried\n# (string, required)\nsymbol: uatom","get-v1pricessymbolsymbol#[GET] /v1/prices/symbol/:symbol":"Get hourly prices via symbol","request-1#Request":"Authorization: Bearer {access_token}\n# Symbol of the asset to be queried\n# (string, required)\nsymbol: uatom\n# End datetime for obtaining prices\n# (datetime, optional, default: CURRENT_TIMESTAMP)\ntoDateTime: 2023-04-21 23:59:59\n# Request per page\n# (number, optional, default: 24)\nticks: 24","get-v1pricescoingeckoidgeckoid#[GET] /v1/prices/coingeckoId/:geckoId":"Get hourly prices via coingeckoId","request-2#Request":"Authorization: Bearer {access_token}\n# CoingeckoId of the asset to be queried\n# (string, required)\ngeckoId: cosmos\n# End datetime for obtaining prices\n# (datetime, optional, default: CURRENT_TIMESTAMP)\ntoDateTime: 2023-04-21 23:59:59\n# Request per page\n# (number, optional, default: 24)\nticks: 24"}},"/extension/guide/chains":{"title":"Chains","data":{"":"Cosmostation Wallet Extension supports various PoS networks.","addremove-chains#Add/Remove Chains":"Add/remove chains to efficiently manage your wallet.Select chains you want to display on the list. Only selected chains will be displayed on both the dashboard and wallet detail page.\nStep 1 View chains that are added to your list. Click 'Add chain' to add/remove chains from the list.Step 2 By toggling on/off, you can choose chains that you want to display on Cosmostation Wallet Extension.Step 3 Selected chains are also visible on the top right side of wallet details."}},"/extension/guide/account/add-ledger-account":{"title":"Add Ledger Account","data":{"":"Create a new ledger wallet","supported-devices--connection-method#Supported Devices & Connection Method":"Ledger S, X\nUSB, HID","adding-ledger-account#Adding Ledger Account":"Account icon → setting icon → Add account → Create a new ledger account → Account name → HD path setting → Done","hd-path-setting#HD path setting":"Up to 101 Ledger accounts and wallets can be derived from a single set of mnemonics in a Ledger by assigning any number smaller than 101 to HD paths when creating a Ledger account.","connecting-ledger#Connecting Ledger":"Select the new Ledger account to connect on home screen.","cosmos-networks#Cosmos Networks":"Cosmostation extension wallet supports Cosmos SDK chain wallets derived from HD paths 44'/118'/0'/0/n. Connecting to any Cosmos SDK chain with a Ledger automatically derives all the Cosmos SDK chain wallets supported by a Ledger account.","evm-networks#EVM Networks":"Cosmostation extension wallet supports EVM wallets derived from HD paths 44'/60'/0'/0/n. Connecting to any EVM network with a Ledger automatically derives all the EVM network wallets supported by a Ledger account.","not-supported-networks#Not Supported Networks":"44'/118'/0'/0/n is a generic HD path for Cosmos SDK chains, but some networks use custom HD paths assigned by their network foundations. For example, a Cosmos SDK chain Crypto.org’s official HD path used by the foundation and Ledger is 44'/394'/0'/0/n.\nIn an effort to sync with the network foundations and Ledger, Cosmostation extension wallet derives wallets solely from HD paths used by the foundations and Ledger. Instead of deriving all the Cosmos SDK chain wallets from 44'/118'/0'/0/n path, Cosmostation only supports the wallets of Cosmos SDK chains whose official HD path is 44'/118'/0'/0/n for now.\nCustom HD path wallets will be supported in future updates.","signing-transactions#Signing Transactions":"","cosmos-sdk-chains#Cosmos SDK Chains":"Open the Cosmos app on Ledger\nCheck the review message on Ledger\nApprove or reject a transaction\nAll the Cosmos SDK chains' transactions can be signed from the Cosmos app.","ethereum--evm#Ethereum & EVM":"Open the Ethereum app on Ledger\nCheck the review message on Ledger\nApprove or reject a transaction\nAll the EVM chains' transactions can be signed from the Ethereum app."}},"/extension/guide/account/intro":{"title":"Introduction","data":{"":"Cosmostation Wallet Extension allows you to add and manage multiple accounts.\nSecurely manage your accounts in a convenient user interface.","add-account#Add Account":"'Add Account' has three options. [Creat a new account], [Import mnemonics], and [Import private key]. Please refer to each page for detailed instructions.\nStep 1 Click 'Add account' under 'Account Management'.Step 2 You will see three options to choose from. Please refer to the following link for detailed instructions.","manage-keys#Manage keys":"Under 'Account Management', you are able to see all the accounts that are registered on Cosmostation Extension.If you created a new account or restored a wallet with a mnemonic phrase, you will be able to see the option to [View mnemonics], [View private key], and [Delete account].If you restored a wallet with a private key, then you will only be able to choose [View private key].","delete-account#Delete Account":"You can delete accounts from Cosmostation Extension.Once deleted, you can restore your account again by importing the same mnemonic phrase or private key.\nYou are required to enter your password before deleting your account.Once deleted, if you lose your mnemonic phrase or private key you will not be able to gain access to the account again."}},"/apis/reference/utilities/node-info":{"title":"Node Info","data":{"get-v1networknode_info#[GET] /v1/:network/node_info":"Get node informations with chain parameters","request#Request":"Authorization: Bearer {access_token}\n# The name of network\n# (string, required)\nnetwork: cosmos"}},"/extension/guide/dapps":{"title":"dApp","data":{"":"Cosmostation Wallet Exntension supports various dApps deployed on PoS networks.","connection-status#Connection status":"Easily check if the wallet extension is connect to the dApp.If you wish to disconnect, click the connection status under your account name.","disconnect-with-just-a-click#Disconnect with just a click.":"Easily disconnect from dApps by clicking the connecting status under your account name."}},"/extension/guide/settings":{"title":"Settings","data":{"":"Customize the wallet extension in wallet settings.","dark-mode#Dark mode":"Toggle back and forth to choose between Dark or Light mode.","address-book#Address Book":"Create different address books for each chain. You can use the address book when using the 'Send' function.\nStep 1 View / Add addresses to the chain you selected.Step 2 Enter address information and click 'Save'.\nLabel your address to distinguish them from one another.\nMemo is optional but required to transfer assets to centralized cryptocurrency\nexchanges. Centralized exchanges will ask you to enter a memo for\nidentification when you make a deposit.\nIf you add addresses in the address book, you can use the address book feature when sending assets.","change-password#Change password":"Enter your current password and to change it to a new password. Enter the new password once more to confirm.\nMake sure that you enter more than 8 characters for the password.","currency--language#Currency & Language":"Cosmostation Wallet Extension supports 2 languages and 5 currencies.\nWe plan to support more currencies and languages in the near future.","lock-screen#Lock screen":"Lock your screen to secure your wallet.\n!"}},"/extension":{"title":"Introduction","data":{"":"Cosmostation Wallet Extension is a non-custodial chrome extension wallet that supports multiple sovereign networks and inter-blockchain bridges. The wallet extension allows users to easily interact with networks and decentralized applications with just a few clicks.To download Cosmostation Wallet Extension, click this link to download from the chrome webstore.","wallet#Wallet":"","dashboard#Dashboard":""}},"/extension/guide/transfer-coins":{"title":"Transfer coins","data":{"":"Transfer coins with just one click via Cosmostation Wallet Extension.\nCosmostation Wallet Extension currently DOES NOT SUPPORT IBC TRANSFERS.If you are trying to send assets to a different chain, the send button will be deactivated.","receive#Receive":"Click 'Deposit' to copy the address to the clipboard or scan the QR code.","send#Send":"The following process is for users sending assets to a different address.\nStep 1 Enter 'Recipient address', 'Amount,' and 'Memo.' The memo field is optional but required for sending to specific centralized cryptocurrency exchanges. Centralized exchanges will ask you to enter a memo for identification when you make a deposit.\nMake sure that you enter the correct recipient address.Entering an incorrect address may result in loss of funds and responsibility of entering the correct address is on the user.\nStep 2, 3 Check the transaction information and confirm."}},"/extension/integration/aptos/connect-and-account":{"title":"Connect, Account","data":{"":"connect and get Account via Cosmostation Extension","connect#Connect":"","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"import { aptos, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await aptos();\n  const account = await provider.connect();\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","vanilla-code#Vanilla Code":"const provider = aptos();\ntry {\n  const account = await provider.connect();\n} catch (e) {\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","response#Response":"export type AptosConnectResponse = {\n  address: string;\n  publicKey: string;\n};\n{\n  \"address\": \"\",\n  \"publicKey\": \"\"\n}","account#Account":"","code-using-cosmostationextension-client-1#Code using @cosmostation/extension-client":"import { aptos, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await aptos();\n  const account = await provider.account();\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","vanilla-code-1#Vanilla Code":"try {\n  const provider = aptos();\n  const account = await provider.account(payload);\n} catch (e) {\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","response-1#Response":"export type AptosAccountResponse = {\n  address: string;\n  publicKey: string;\n};\n{\n  \"address\": \"\",\n  \"publicKey\": \"\"\n}"}},"/extension/integration/aptos/event":{"title":"Event","data":{"accountchange#AccountChange":"","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"import { aptos, InstallError } from \"@cosmostation/extension-client\";\nconst handler = (account) => console.log(account);\ntry {\n  const provider = await aptos();\n  provider.onAccountChange(handler);\n  // if you want to remove the listener\n  provider.offAccountChange(handler);\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n}","vanilla-code#Vanilla Code":"const handler = (account) => console.log(account);\ntry {\n  const provider = aptos();\n  provider.onAccountChange(handler);\n  // if you want to remove the listener\n  provider.offAccountChange(handler);\n} catch (e) {\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","networkchange#NetworkChange":"","code-using-cosmostationextension-client-1#Code using @cosmostation/extension-client":"import { aptos, InstallError } from \"@cosmostation/extension-client\";\nconst handler = (network) => console.log(network);\ntry {\n  const provider = await aptos();\n  provider.onNetworkChange(handler);\n  // if you want to remove the listener\n  provider.offNetworkChange(handler);\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n}","vanilla-code-1#Vanilla Code":"const handler = (network) => console.log(network);\ntry {\n  const provider = aptos();\n  provider.onNetworkChange(handler);\n  // if you want to remove the listener\n  provider.offNetworkChange(handler);\n} catch (e) {\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}"}},"/extension/integration/aptos/network":{"title":"Network","data":{"":"Get Network via Cosmostation Extension","network#Network":"","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"import { aptos, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await aptos();\n  const network = await provider.network();\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","vanilla-code#Vanilla Code":"try {\n  const provider = aptos();\n  const network = await provider.network(payload);\n} catch (e) {\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","response#Response":"export type AptosNetworkResponse = string;\n\"Mainnet\""}},"/extension/integration/aptos/provider":{"title":"Provider","data":{"":"Cosmostation extension support various chains.","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"import { aptos, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await aptos();\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n}","vanilla-code#Vanilla Code":"const isCosmostation = \"cosmostation\" in window;\nconst aptos = () => {\n  if (\"cosmostation\" in window) {\n    return window.cosmostation.aptos;\n  } else {\n    window.open(\"https://cosmostation.io/wallet/#extension\");\n    /**\n     * or window.open(\"https://chrome.google.com/webstore/detail/cosmostation/fpkhgmpbidmiogeglndfbkegfdlnajnf\");\n     * */\n  }\n};\nconst provider = aptos();"}},"/extension/integration/aptos/sign-and-submit-transaction":{"title":"Sign And Submit Transaction","data":{"":"Sign And Submit transaction via Cosmostation Extension","signandsubmittransaction#SignAndSubmitTransaction":"","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"import { aptos, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await aptos();\n  // e.g. send payload\n  const payload = {\n    arguments: [\n      \"\",\n      \"100000000\",\n    ],\n    function: \"0x1::aptos_account::transfer\",\n    type: \"entry_function_payload\",\n    type_arguments: [],\n  };\n  const pendingTransaction = await provider.signAndSubmitTransaction(payload);\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","vanilla-code#Vanilla Code":"// e.g. send payload\nconst payload = {\n  arguments: [\n    \"\",\n    \"100000000\",\n  ],\n  function: \"0x1::aptos_account::transfer\",\n  type: \"entry_function_payload\",\n  type_arguments: [],\n};\ntry {\n  const provider = aptos();\n  const pendingTransaction = await provider.signAndSubmitTransaction(payload);\n} catch (e) {\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","request#request":"export type AptosSignPayload<T = unknown> = {\n  function: string;\n  type: string;\n  type_arguments: string[];\n  arguments: T[];\n};","response#Response":"export type AptosSignAndSubmitTransactionResponse = {\n  hash: string;\n  sender: string;\n  sequence_number: string;\n  max_gas_amount: string;\n  gas_unit_price: string;\n  expiration_timestamp_secs: string;\n  payload: AptosSignPayload;\n  signature?: {\n    type: string;\n    public_key: string;\n    signature: string;\n  };\n};\n{\n  \"hash\": \"\",\n  \"sender\": \"\",\n  \"sequence_number\": \"15\",\n  \"max_gas_amount\": \"1016\",\n  \"gas_unit_price\": \"100\",\n  \"expiration_timestamp_secs\": \"1668137878\",\n  \"payload\": {\n    \"function\": \"0x1::coin::transfer\",\n    \"type_arguments\": [\"0x1::aptos_coin::AptosCoin\"],\n    \"arguments\": [\n      \"\",\n      \"1000000\"\n    ],\n    \"type\": \"entry_function_payload\"\n  },\n  \"signature\": {\n    \"public_key\": \"\",\n    \"signature\": \"\",\n    \"type\": \"ed25519_signature\"\n  }\n}","signtransaction#SignTransaction":"","code-using-cosmostationextension-client-1#Code using @cosmostation/extension-client":"import { aptos, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await aptos();\n  const signature = await provider.signTransaction(payload);\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","vanilla-code-1#Vanilla Code":"const cosmostation = provider();\n// e.g. send payload\nconst payload = {\n  arguments: [\n    \"\",\n    \"100000000\",\n  ],\n  function: \"0x1::aptos_account::transfer\",\n  type: \"entry_function_payload\",\n  type_arguments: [],\n};\ntry {\n  const provider = aptos();\n  const signature = await provider.signTransaction(payload);\n} catch (e) {\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n}","request-1#request":"export type AptosSignPayload<T = unknown> = {\n  function: string;\n  type: string;\n  type_arguments: string[];\n  arguments: T[];\n};","response-1#Response":"export type AptosSignTransactionResponse = string;\n\"\""}},"/extension/integration/cosmos/Deprecated/disconnect":{"title":"Disconnect","data":{"":"Disconnect from Dapp","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"const response = await provider.disconnect();","vanilla-code#Vanilla Code":"const response = await window.cosmostation.cosmos.request({\n  method: \"cos_disconnect\",\n});","response#Response":"type DisconnectResponse = null;\nnull"}},"/extension/integration/cosmos/Deprecated/chains":{"title":"Chains","data":{"":"Get supported chains and add specific chains for using Cosmostation Extension.","add-chains#Add chains":"","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"try {\n  // ...\n  await provider.addChain({\n    chainId: \"cerberus-chain-1\",\n    chainName: \"cerberus\",\n    addressPrefix: \"cre\",\n    baseDenom: \"ucrbrus\",\n    displayDenom: \"CRBRUS\",\n    restURL: \"https://lcd-office.cosmostation.io/mooncat-1-1\",\n    coinType: \"118\", // optional (default: '118')\n    decimals: 6, // optional (default: 6)\n    gasRate: {\n      // optional (default: { average: '0.025', low: '0.0025', tiny: '0.00025' })\n      average: \"0.2\",\n      low: \"0.02\",\n      tiny: \"0.002\",\n    },\n    sendGas: \"80000\", // optional (default: '100000')\n    type: \"ETHERMINT\", // optional (default: '')\n  });\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n  // exception\n}","vanilla-code#Vanilla Code":"await window.cosmostation.cosmos.request({\n  method: \"cos_addChain\",\n  params: {\n    chainId: \"cerberus-chain-1\",\n    chainName: \"cerberus\",\n    addressPrefix: \"cre\",\n    baseDenom: \"ucrbrus\",\n    displayDenom: \"CRBRUS\",\n    restURL: \"https://lcd-office.cosmostation.io/mooncat-1-1\",\n    coinType: \"118\", // optional (default: '118')\n    decimals: 6, // optional (default: 6)\n    gasRate: {\n      // optional (default: { average: '0.025', low: '0.0025', tiny: '0.00025' })\n      average: \"0.2\",\n      low: \"0.02\",\n      tiny: \"0.002\",\n    },\n    sendGas: \"80000\", // optional (default: '100000')\n    type: \"ETHERMINT\", // optional (default: '')\n  },\n});","response#Response":"type addChainResponse = boolean;\ntrue","keplr-to-cosmostation#keplr to cosmostation":"{\n  chainId: chainInfo.chainId,\n  addressPrefix: chainInfo.bech32Config.bech32PrefixAccAddr,\n  baseDenom: chainInfo.currencies[0].coinMinimalDenom,\n  chainName: chainInfo.chainName || chainInfo.chainId,\n  displayDenom: chainInfo.currencies[0].coinDenom,\n  decimals: chainInfo.currencies[0].coinDecimals,\n  restURL: chainInfo.rest,\n  coinType: String(chainInfo.bip44.coinType),\n  gasRate: chainInfo.gasPriceStep\n    ? {\n        tiny: String(chainInfo.gasPriceStep.low),\n        low: String(chainInfo.gasPriceStep.average),\n        average: String(chainInfo.gasPriceStep.high),\n      }\n    : undefined,\n}\nexport interface KeplrChainInfo {\n  readonly rpc: string;\n  readonly rpcConfig?: AxiosRequestConfig;\n  readonly rest: string;\n  readonly restConfig?: AxiosRequestConfig;\n  readonly chainId: string;\n  readonly chainName: string;\n  readonly stakeCurrency: Currency;\n  readonly walletUrl?: string;\n  readonly walletUrlForStaking?: string;\n  readonly bip44: BIP44;\n  readonly alternativeBIP44s?: BIP44[];\n  readonly bech32Config: Bech32Config;\n  readonly currencies: AppCurrency[];\n  readonly feeCurrencies: FeeCurrency[];\n  readonly features?: string[];\n  readonly beta?: boolean;\n}","supported-chains#Supported chains":"","code-using-cosmostationextension-client-1#Code using @cosmostation/extension-client":"const supportedChains = await provider.getSupportedChains();","vanilla-code-1#Vanilla Code":"const supportedChains = await window.cosmostation.cosmos.request({\n  method: \"cos_supportedChainNames\",\n});","response-1#Response":"type SupportedChainNamesResponse = {\n  official: string[]; // lowercase\n  unofficial: string[]; // lowercase\n};\n{\n  \"official\": [\"cosmos\", \"osmosis\"],\n  \"unofficial\": [\"test\"]\n}","supported-chainids#Supported chainIds":"","code-using-cosmostationextension-client-2#Code using @cosmostation/extension-client":"const supportedChains = await provider.getSupportedChainIds();","vanilla-code-2#Vanilla Code":"const supportedChainIds = await window.cosmostation.cosmos.request({\n  method: \"cos_supportedChainIds\",\n});","response-2#Response":"type SupportedChainIdsResponse = {\n  official: string[];\n  unofficial: string[];\n};\n{\n  \"official\": [\"cosmoshub-4\", \"gravity-bridge-3\"],\n  \"unofficial\": [\"columbus-5\", \"agoric-3\"]\n}","activated-chains#Activated chains":"","code-using-cosmostationextension-client-3#Code using @cosmostation/extension-client":"const activatedChains = await provider.getActivatedChains();","vanilla-code-3#Vanilla Code":"const activatedChains = await window.cosmostation.cosmos.request({\n  method: \"cos_activatedChainNames\",\n});","response-3#Response":"type ActivatedChainNamesResponse = string[]; // lowercase\n[\"cosmos\", \"osmosis\"]","activated-chainids#Activated chainIds":"","code-using-cosmostationextension-client-4#Code using @cosmostation/extension-client":"const activatedChainIds = await provider.getActivatedChainIds();","vanilla-code-4#Vanilla Code":"const activatedChainIds = await window.cosmostation.cosmos.request({\n  method: \"cos_activatedChainIds\",\n});","response-4#Response":"type ActivatedChainIdsResponse = string[];\n[\"cosmoshub-4\", \"gravity-bridge-3\"]"}},"/extension/integration/cosmos/Deprecated/accounts":{"title":"Accounts","data":{"":"Using Cosmostation Extension accounts.","get-accounts#Get Accounts":"","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"const account = await provider.getAccount(\"cosmoshub-4\");","vanilla-code#Vanilla Code":"const account = await window.cosmostation.cosmos.request({\n  method: \"cos_account\",\n  params: { chainName: \"cosmoshub-4\" },\n});","if-connected-successfully-it-will-look-like-below#If connected successfully, it will look like below.":"","response#Response":"type AccountResponse = {\n  name: string;\n  address: string;\n  publicKey: Uint8Array;\n  isLedger: boolean;\n};\n{\n  \"name\": \"account name\",\n  \"address\": \"cosmos1wgeoiheoighwoighwioeghoweghoiweghiow\",\n  \"publicKey\": [\n    3, 77, 9, 189, 251, 249, 150, 235, 192, 56, 51, 98, 56, 242, 12, 102, 144,\n    211, 89, 42, 187, 170\n  ],\n  \"isLedger\": false\n}","request-account-popup#Request Account (Popup)":"","code-using-cosmostationextension-client-1#Code using @cosmostation/extension-client":"try {\n  // ...\n  const account = await provider.requestAccount(\"cosmoshub-4\");\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n  // exception\n}","vanilla-code-1#Vanilla Code":"const account = await window.cosmostation.cosmos.request({\n  method: \"cos_requestAccount\",\n  params: { chainName: \"cosmoshub-4\" },\n});","response-1#Response":"type RequestAccountResponse = {\n  name: string;\n  address: string;\n  publicKey: Uint8Array;\n  isLedger: boolean;\n};\n{\n  \"name\": \"account name\",\n  \"address\": \"cosmos1wgeoiheoighwoighwioeghoweghoiweghiow\",\n  \"publicKey\": [\n    3, 77, 9, 189, 251, 249, 150, 235, 192, 56, 51, 98, 56, 242, 12, 102, 144,\n    211, 89, 42, 187, 170\n  ],\n  \"isLedger\": false\n}"}},"/extension/integration/cosmos/Deprecated/error":{"title":"Error","data":{"":"Error description\nCode\tModel\tDescription\t4001\t-\tUser rejected request\t4100\t-\tThe requested account and/or method has not been authorized by the user.\t4200\t-\tThe requested method is not supported\t-32000\t-\tInvalid input.\t-32600\t-\tThe JSON sent is not a valid Request object.\t-32602\t-\tInvalid method parameter(s).\t-32603\t-\tInternal JSON-RPC error."}},"/extension/integration/cosmos/Deprecated/event":{"title":"Event","data":{"":"Account change event","onaccountchanged#onAccountChanged":"","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"provider.onAccountChanged(() => console.log(\"changed\"));","vanilla-code#Vanilla Code":"window.addEventListener(\"cosmostation_keystorechange\", () => {\n    console.log(\"Key store in Cosmostation is changed. You may need to refetch the account info.\")\n})","offaccountchanged#offAccountChanged":"","code-using-cosmostationextension-client-1#Code using @cosmostation/extension-client":"const event = provider.onAccountChanged(() => console.log(\"changed\"));\nprovider.offAccountChanged(event);","vanilla-code-1#Vanilla Code":"window.removeEventListener(\"cosmostation_keystorechange\", handler)"}},"/extension/integration/cosmos/Deprecated/sign-message":{"title":"Sign Message","data":{"":"Sign Message via Cosmostation Extension","sign-message#Sign Message":"","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"try {\n  // ...\n  const response = await provider.signMessage(\n    \"cosmoshub-4\",\n    \"cosmos1gr0e3pj3y6fqvzyfm0qxyw9h5dwfrvh8zv3x9p\", // signer\n    \"message!!!!\" // message\n  );\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n  // exception\n}","vanilla-code#Vanilla Code":"const response = await window.cosmostation.cosmos.request({\n  method: \"cos_signMessage\",\n  params: {\n    chainName: \"cosmoshub-4\",\n    signer: \"cosmos1gr0e3pj3y6fqvzyfm0qxyw9h5dwfrvh8zv3x9p\",\n    message: \"message!!!!\",\n  },\n});","response#Response":"export type SignMessageResponse = {\n  signature: string;\n  pub_key: { type: string; value: string };\n};\n{\n  \"pub_key\": {\n    \"type\": \"tendermint/PubKeySecp256k1\",\n    \"value\": \"A00Jvfv5luvAODNiOPIMZpDTWSq7qvoFV8k7ptdsDqLU\"\n  },\n  \"signature\": \"signature==\"\n}","verifymessage#VerifyMessage":"","code-using-cosmostationextension-client-1#Code using @cosmostation/extension-client":"try {\n  const response = await provider.signMessage(\n    \"cosmoshub-4\",\n    \"cosmos1gr0e3pj3y6fqvzyfm0qxyw9h5dwfrvh8zv3x9p\",\n    \"message!!!!\"\n  );\n  const result = await provider.verifyMessage(\n    \"cosmoshub-4\",\n    \"cosmos1gr0e3pj3y6fqvzyfm0qxyw9h5dwfrvh8zv3x9p\",\n    \"message!!!!\",\n    response\n  );\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n  // exception\n}","vanilla-code-1#Vanilla Code":"const response = await window.cosmostation.cosmos.request({\n  method: \"cos_signMessage\",\n  params: {\n    chainName: \"cosmoshub-4\",\n    signer: \"cosmos1gr0e3pj3y6fqvzyfm0qxyw9h5dwfrvh8zv3x9p\",\n    message: \"message!!!!\",\n  },\n});\nconst result = await window.cosmostation.cosmos.request({\n  method: \"cos_verifyMessage\",\n  params: {\n    chainName: \"cosmoshub-4\",\n    signer: \"cosmos1gr0e3pj3y6fqvzyfm0qxyw9h5dwfrvh8zv3x9p\",\n    message: \"message!!!!\",\n    publicKey: response.pub_key.value,\n    signature: response.signature,\n  },\n});","response-1#Response":"export type VerifyMessageResponse = boolean;\ntrue"}},"/extension/integration/cosmos/Deprecated/provider":{"title":"Provider","data":{"":"Cosmostation extension support various chains.","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"import { cosmos, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await cosmos();\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n}","vanilla-code#Vanilla Code":"window.onload = async () => {\n  if (!window.cosmostation) {\n    alert(\"Please install cosmostation extension\");\n  } else {\n    // logic\n  }\n};"}},"/extension/integration/cosmos/Deprecated/cw20-token":{"title":"CW20 token","data":{"":"@cosmostation/extension-client >= 0.1.7CW20 token via Cosmostation Extension","add-cw20-tokens#Add CW20 Tokens":"","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"// ...\nconst response = await provider.addCW20Tokens('mint', [\n  {\n    contractAddress: '',\n    imageURL: 'https://pbs.twimg.com/profile_images/1465777324859826197/RUXx0equ_400x400.jpg', // optional\n    coinGeckoId: 'neta', // optional\n  },\n  {\n    contractAddress: '',\n  },\n]);","vanilla-code#Vanilla Code":"const response = await window.cosmostation.cosmos.request({\n  method: 'cos_addTokensCW20',\n  params: {\n    chainName: 'mint',\n    tokens: [\n      {\n        contractAddress: '',\n        imageURL: 'https://pbs.twimg.com/profile_images/1465777324859826197/RUXx0equ_400x400.jpg', // optional\n        coinGeckoId: 'neta', // optional\n      },\n      {\n        contractAddress: '',\n      },\n    ],\n  },\n});","response#Response":"export type AddCW20TokenResponse = null;\nnull","get-cw20-token-balance#Get CW20 Token Balance":"","code-using-cosmostationextension-client-1#Code using @cosmostation/extension-client":"// ...\nconst response = await provider.getCW20TokenBalance(\n  'mint',\n  '', // contract address\n  'mint14xgdfdnpjtulj6p7rkc75ekxqjq8hc5cg5evx3', // address\n);","vanilla-code-1#Vanilla Code":"const response = await window.cosmostation.cosmos.request({\n  method: 'cos_getBalanceCW20',\n  params: {\n    chainName: 'mint',\n    contractAddress: '',\n    address: 'mint14xgdfdnpjtulj6p7rkc75ekxqjq8hc5cg5evx3',\n  },\n});","response-1#Response":"export type getCW20TokenBalanceResponse = string;\n\"1331775394\"","get-cw20-token-info#Get CW20 Token Info":"","code-using-cosmostationextension-client-2#Code using @cosmostation/extension-client":"// ...\nconst response = await provider.getCW20TokenInfo(\n  'mint',\n  '', // contract address\n);","vanilla-code-2#Vanilla Code":"const response = await window.cosmostation.cosmos.request({\n  method: 'cos_getTokenInfoCW20',\n  params: {\n    chainName: 'mint',\n    contractAddress: '',\n  },\n});","response-2#Response":"export type getCW20TokenInfoResponse = {\n  decimals: number;\n  name: string;\n  symbol: string;\n  total_supply: string;\n};\n{\n  \"name\": \"NETA\",\n  \"symbol\": \"NETA\",\n  \"decimals\": 6,\n  \"total_supply\": \"31886600000\"\n}"}},"/extension/integration/cosmos/integrate-cosmjs":{"title":"Integrate cosmjs","data":{"":"Integrate cosmjs.","add-package#Add package":"yarn add @cosmostation/cosmos-client\nnpm install @cosmostation/cosmos-client","offline-signer#Offline Signer":"import { getOfflineSigner } from \"@cosmostation/cosmos-client\";\nconst offlineSigner = await getOfflineSigner(CHAIN_ID);\nimport { getOfflineSigner } from \"@cosmostation/cosmos-client\";\nimport { GasPrice, calculateFee } from \"@cosmjs/stargate\";\nimport { SigningCosmWasmClient } from \"@cosmjs/cosmwasm-stargate\";\nconst offlineSigner = await getOfflineSigner(CHAIN_ID);\nconst rpcEndpoint = RPC_END_POINT;\nconst client = await SigningCosmWasmClient.connectWithSigner(\n  rpcEndpoint,\n  offlineSigner\n);\n//getAccounts\nconst accounts = await offlineSigner.getAccounts();\n//execute\nconst gasPrice = GasPrice.fromString(\"0.01denom\");\nconst fees = {\n  upload: calculateFee(1500000, gasPrice),\n  init: calculateFee(500000, gasPrice),\n  exec: calculateFee(500000, gasPrice),\n};\nconst result = await client.execute(\n  accounts[0].address,\n  RECEIPT_ADDRESS,\n  MESSAGE,\n  fees.exec\n);"}},"/extension/integration/cosmos/integrate-keplr":{"title":"Use Cosmostation with Keplr Interface","data":{"":"Cosmostation is providing Keplr's interface. The purpose is to make it easier for the developers to integrate Cosmostation to dApps that have Keplr integrated already.Supported functions/variables are as belows:\ndefaultOptions\nenable\ngetKey\nexperimentalSuggestChain\ngetOfflineSigner\ngetOfflineSignerAuto\ngetOfflineSignerOnlyAmino\nsendTx\nsignAmino\nsignDirect\nsignArbitrary\nverifyArbitrary\nIn case of an error, use the Cosmostation interface.You need to use methods provided by Cosmostation for the event handling and defaultOptions change.\nHere's the guide:","guide#Guide":"Use window.cosmostation.providers.keplr instead of window.keplr.\nwindow.onload = async () => {\n  if (!window.cosmostation) {\n    alert(\"Please install cosmostation extension\");\n  } else {\n    const chainId = \"cosmoshub-4\";\n    await window.cosmostation.providers.keplr.enable(chainId);\n    const offlineSigner =\n      window.cosmostation.providers.keplr.getOfflineSigner(chainId);\n    const accounts = await offlineSigner.getAccounts();\n  }\n};\nasync getKeplr(): Promise<Keplr | undefined> {\n    if (window.cosmostation) {\n        return window.cosmostation.providers.keplr;\n    }\n    if (document.readyState === \"complete\") {\n        return window.cosmostation.providers.keplr;\n    }\n    return new Promise((resolve) => {\n        const documentStateChange = (event: Event) => {\n            if (\n                event.target &&\n                (event.target as Document).readyState === \"complete\"\n            ) {\n                resolve(window.cosmostation.providers.keplr);\n                document.removeEventListener(\"readystatechange\", documentStateChange);\n            }\n        };\n        document.addEventListener(\"readystatechange\", documentStateChange);\n    });\n}","defaultoptions#defaultOptions":"window.cosmostation.providers.keplr.defaultOptions = {\n  sign: {\n    preferNoSetFee: true,\n    preferNoSetMemo: true,\n  },\n};","event#Event":"window.addEventListener(\"cosmostation_keystorechange\", () => {\n    console.log(\"Key store in Cosmostation is changed. You may need to refetch the account info.\")\n})"}},"/extension/integration/cosmos/Deprecated/sign-tx":{"title":"Sign Transactions","data":{"":"Sign transaction via Cosmostation Extension","sign-amino#Sign Amino":"","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"try {\n  // ...\n  const response = await provider.signAmino(\n    \"cosmoshub-4\",\n    {\n      chain_id: \"cosmoshub-4\",\n      fee: { amount: [{ denom: \"uatom\", amount: \"5000\" }], gas: \"200000\" },\n      memo: \"\",\n      msgs: [\n        {\n          type: \"cosmos-sdk/MsgSend\",\n          value: {\n            from_address: \"cosmos1wepghweioghweiog\",\n            to_address: \"cosmos1weogihweoighweoigheoiw\",\n            amount: [{ denom: \"uatom\", amount: \"5000\" }],\n          },\n        },\n      ],\n      sequence: \"20\",\n      account_number: \"632177\",\n    },\n    {\n      memo: true, // optional\n      fee: true, // optional\n      gasRate: {\n        // optional\n        average: \"0.2\",\n        low: \"0.02\",\n        tiny: \"0.002\",\n      },\n    }\n  );\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n  // exception\n}","vanilla-code#Vanilla Code":"const response = await window.cosmostation.cosmos.request({\n  method: \"cos_signAmino\",\n  params: {\n    chainName: \"cosmoshub-4\",\n    doc: {\n      chain_id: \"cosmoshub-4\",\n      fee: { amount: [{ denom: \"uatom\", amount: \"5000\" }], gas: \"200000\" },\n      memo: \"\",\n      msgs: [\n        {\n          type: \"cosmos-sdk/MsgSend\",\n          value: {\n            from_address: \"cosmos1wepghweioghweiog\",\n            to_address: \"cosmos1weogihweoighweoigheoiw\",\n            amount: [{ denom: \"uatom\", amount: \"5000\" }],\n          },\n        },\n      ],\n      sequence: \"20\",\n      account_number: \"632177\",\n    },\n    isEditMemo: true, // optional\n    isEditFee: true, // optional\n    gasRate: {\n      // optional\n      average: \"0.2\",\n      low: \"0.02\",\n      tiny: \"0.002\",\n    },\n  },\n});","response#Response":"export type SignAminoResponse = {\n  signature: string;\n  pub_key: { type: string; value: string };\n  signed_doc: SignAminoDoc;\n};\nexport type SignAminoDoc = {\n  chain_id: string;\n  sequence: string;\n  account_number: string;\n  fee: Fee;\n  memo: string;\n  msgs: Msg[];\n};\nexport type Amount = {\n  denom: string;\n  amount: string;\n};\nexport type Msg<T = unknown> = {\n  type: string;\n  value: T;\n};\nexport type Fee = { amount: Amount[]; gas: string };\n{\n  \"pub_key\": {\n    \"type\": \"tendermint/PubKeySecp256k1\",\n    \"value\": \"A00Jvfv5luvAODNiOPIMZpDTWSq7qvoFV8k7ptdsDqLU\"\n  },\n  \"signature\": \"signature==\",\n  \"signed_doc\": {\n    \"chain_id\": \"cosmoshub-4\",\n    \"fee\": {\n      \"amount\": [{ \"denom\": \"uatom\", \"amount\": \"5000\" }],\n      \"gas\": \"200000\"\n    },\n    \"memo\": \"\",\n    \"msgs\": [\n      {\n        \"type\": \"cosmos-sdk/MsgSend\",\n        \"value\": {\n          \"from_address\": \"cosmos1gr0e3pj3y6fqvzyfm0qxyw9h5dwfrvh8zv3x9p\",\n          \"to_address\": \"cosmos1ursv4z57pw8ly2jsgn09dyjha4qrk7aen987ld\",\n          \"amount\": [{ \"denom\": \"uatom\", \"amount\": \"5000\" }]\n        }\n      }\n    ],\n    \"sequence\": \"20\",\n    \"account_number\": \"632177\"\n  }\n}","sign-direct#Sign Direct":"","code-using-cosmostationextension-client-1#Code using @cosmostation/extension-client":"try {\n  // ...\n  const response = await provider.signDirect(\n    \"cosmos\",\n    {\n      chain_id: \"cosmoshub-4\",\n      account_number: \"1\",\n      auth_info_bytes: [\n        10, 80, 10, 70, 10, 31, 47, 99, 111, 115, 109, 111, 115, 46, 99, 114,\n        121, 112, 116, 111, 46, 115, 101, 99, 112, 50, 53, 54, 107, 49, 46, 80,\n        117, 98, 75, 101, 121, 18, 35, 10, 33, 3, 77, 9, 189, 251, 249, 150,\n        235, 192, 56, 51, 98, 56, 242, 12, 102, 144, 211, 89, 42, 187, 170, 250,\n        5, 87, 201, 59, 166, 215, 108, 14, 162, 212, 18, 4, 10, 2, 8, 127, 24,\n        14, 18, 19, 10, 13, 10, 5, 117, 97, 116, 111, 109, 18, 4, 50, 48, 48,\n        48, 16, 128, 241, 4,\n      ],\n      body_bytes: [\n        10, 133, 1, 10, 28, 47, 99, 111, 115, 109, 111, 115, 46, 98, 97, 110,\n        107, 46, 118, 49, 98, 101, 116, 97, 49, 46, 77, 115, 103, 83, 101, 110,\n        100, 18, 101, 10, 42, 99, 114, 101, 49, 103, 114, 48, 101, 51, 112, 106,\n        51, 121, 54, 102, 113, 118, 122, 121, 102, 109, 48, 113, 120, 121, 119,\n        57, 104, 53, 100, 119, 102, 114, 118, 104, 56, 120, 121, 122, 114, 115,\n        118, 18, 42, 99, 114, 101, 49, 120, 53, 119, 103, 104, 54, 118, 119,\n        121, 101, 54, 48, 119, 118, 51, 100, 116, 115, 104, 115, 57, 100, 109,\n        113, 103, 103, 119, 102, 120, 50, 108, 100, 104, 103, 108, 117, 101,\n        122, 26, 11, 10, 4, 117, 99, 114, 101, 18, 3, 49, 48, 48, 18, 0,\n      ],\n    },\n    { memo: true, fee: true } // edit | optional (default: { memo: false, fee: false }),\n  );\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  if (e.code === 4001) {\n    console.log(\"user rejected request\");\n  }\n  // exception\n}","vanilla-code-1#Vanilla Code":"const response = await window.cosmostation.cosmos.request({\n  method: \"cos_signDirect\",\n  params: {\n    chainName: \"cosmos\",\n    doc: {\n      chain_id: \"cosmoshub-4\",\n      account_number: \"1\",\n      auth_info_bytes: [\n        10, 80, 10, 70, 10, 31, 47, 99, 111, 115, 109, 111, 115, 46, 99, 114,\n        121, 112, 116, 111, 46, 115, 101, 99, 112, 50, 53, 54, 107, 49, 46, 80,\n        117, 98, 75, 101, 121, 18, 35, 10, 33, 3, 77, 9, 189, 251, 249, 150,\n        235, 192, 56, 51, 98, 56, 242, 12, 102, 144, 211, 89, 42, 187, 170, 250,\n        5, 87, 201, 59, 166, 215, 108, 14, 162, 212, 18, 4, 10, 2, 8, 127, 24,\n        14, 18, 19, 10, 13, 10, 5, 117, 97, 116, 111, 109, 18, 4, 50, 48, 48,\n        48, 16, 128, 241, 4,\n      ],\n      body_bytes: [\n        10, 133, 1, 10, 28, 47, 99, 111, 115, 109, 111, 115, 46, 98, 97, 110,\n        107, 46, 118, 49, 98, 101, 116, 97, 49, 46, 77, 115, 103, 83, 101, 110,\n        100, 18, 101, 10, 42, 99, 114, 101, 49, 103, 114, 48, 101, 51, 112, 106,\n        51, 121, 54, 102, 113, 118, 122, 121, 102, 109, 48, 113, 120, 121, 119,\n        57, 104, 53, 100, 119, 102, 114, 118, 104, 56, 120, 121, 122, 114, 115,\n        118, 18, 42, 99, 114, 101, 49, 120, 53, 119, 103, 104, 54, 118, 119,\n        121, 101, 54, 48, 119, 118, 51, 100, 116, 115, 104, 115, 57, 100, 109,\n        113, 103, 103, 119, 102, 120, 50, 108, 100, 104, 103, 108, 117, 101,\n        122, 26, 11, 10, 4, 117, 99, 114, 101, 18, 3, 49, 48, 48, 18, 0,\n      ],\n    },\n    isEditFee: true,\n    isEditMemo: true,\n  },\n});","response-1#Response":"export type SignDirectDoc = {\n  chain_id: string;\n  body_bytes: Uint8Array;\n  auth_info_bytes: Uint8Array;\n  account_number: string;\n};\nexport type SignDirectResponse = {\n  signature: string;\n  pub_key: { type: string; value: string };\n  signed_doc: SignDirectDoc;\n};\n{\n  \"pub_key\": {\n    \"type\": \"tendermint/PubKeySecp256k1\",\n    \"value\": \"A00Jvfv5luvAODNiOPIMZpDTWSq7qvoFV8k7ptdsDqLU\"\n  },\n  \"signature\": \"signature==\",\n  \"signed_doc\": {\n    \"chain_id\": \"cosmoshub-4\",\n    \"account_number\": \"1\",\n    \"auth_info_bytes\": [\n      10, 80, 10, 70, 10, 31, 47, 99, 111, 115, 109, 111, 115, 46, 99, 114, 121,\n      112, 116, 111, 46, 115, 101, 99, 112, 50, 53, 54, 107, 49, 46, 80, 117,\n      98, 75, 101, 121, 18, 35, 10, 33, 3, 77, 9, 189, 251, 249, 150, 235, 192,\n      56, 51, 98, 56, 242, 12, 102, 144, 211, 89, 42, 187, 170, 250, 5, 87, 201,\n      59, 166, 215, 108, 14, 162, 212, 18, 4, 10, 2, 8, 127, 24, 14, 18, 19, 10,\n      13, 10, 5, 117, 97, 116, 111, 109, 18, 4, 50, 48, 48, 48, 16, 128, 241, 4\n    ],\n    \"body_bytes\": [\n      10, 133, 1, 10, 28, 47, 99, 111, 115, 109, 111, 115, 46, 98, 97, 110, 107,\n      46, 118, 49, 98, 101, 116, 97, 49, 46, 77, 115, 103, 83, 101, 110, 100,\n      18, 101, 10, 42, 99, 114, 101, 49, 103, 114, 48, 101, 51, 112, 106, 51,\n      121, 54, 102, 113, 118, 122, 121, 102, 109, 48, 113, 120, 121, 119, 57,\n      104, 53, 100, 119, 102, 114, 118, 104, 56, 120, 121, 122, 114, 115, 118,\n      18, 42, 99, 114, 101, 49, 120, 53, 119, 103, 104, 54, 118, 119, 121, 101,\n      54, 48, 119, 118, 51, 100, 116, 115, 104, 115, 57, 100, 109, 113, 103,\n      103, 119, 102, 120, 50, 108, 100, 104, 103, 108, 117, 101, 122, 26, 11,\n      10, 4, 117, 99, 114, 101, 18, 3, 49, 48, 48, 18, 0\n    ]\n  }\n}"}},"/extension/integration/cosmos/react-hook":{"title":"React hook","data":{"installation#Installation":"The Cosmostation wallet hook package lives in npm. To install the latest stable version, run the following command:\nnpm install @cosmostation/use-wallets\nOr if you're using yarn:\nyarn add @cosmostation/use-wallets","cosmosprovider#CosmosProvider":"Components that use cosmos wallet state need CosmosProvider to appear somewhere in the parent tree. A good place to put this is in your root component:\nimport { CosmosProvider } from '@cosmostation/use-wallets';\nfunction App() {\n  return (\n    <CosmosProvider>\n      <MyApp />\n    </CosmosProvider>\n  );\n}","usecosmoswallets#useCosmosWallets":"With useCosmosWallets, you can select a list of wallets, the wallet you are currently using, and the wallet you want to use.\nThe wallet list is automatically inserted in extensions.If you would like to add a wallet, click here","selectwallet#selectWallet":"import { useCosmosWallets } from '@cosmostation/use-wallets';\nfunction Connect() {\n  const { cosmosWallets, selectWallet } = useCosmosWallets();\n  return (\n    <div>\n      {cosmosWallets.map((wallet) => (\n        <button\n          onClick={() => {\n            selectWallet(wallet.id);\n          }}\n          key={wallet.id}\n        >\n          <img src={wallet.logo} alt={wallet.name} width={40} height={40} /> {wallet.name}\n        </button>\n      ))}\n    </div>\n  );\n}","addchain#addChain":"import { useCosmosWallets } from '@cosmostation/use-wallets';\nfunction AddCustomChain() {\n  const { currentWallet } = useCosmosWallets();\n  return (\n    <div>\n      <button\n        onClick={() => {\n          try {\n            if (!currentWallet) {\n              throw new Error('No Selected Wallet');\n            }\n            await currentWallet.methods.addChain({\n              chain_id: 'custom-chain-1',\n              chain_name: 'custom-chain',\n              address_prefix: 'custom',\n              base_denom: 'ucustom',\n              display_denom: 'CUSTOM',\n              lcd_url: 'https://rpc.custom-chain.com',\n              decimals: 6, // optional\n              coin_type: \"118'\", // optional\n            });\n          } catch (e) {\n            console.log(e.message);\n          }\n        }}\n      >\n        Add Custom Chain\n      </button>\n    </div>\n  );\n}","usecosmosaccount#useCosmosAccount":"With useCosmosAccount, you can get the account information of the wallet you are currently using.","account#Account":"Account automatically requests account information the moment a wallet is selected. If you want to request more manually, you can use 'mutate'.\nType\nimport { useCosmosAccount } from '@cosmostation/use-wallets';\nexport default function Account() {\n  const { data, error, mutate } = useCosmosAccount('cosmoshub-4');\n  useEffect(() => {\n    console.log('address', data?.account);\n    console.log('error', error);\n  }, [data, error]);\n  return <button onClick={() => mutate()}>Request Account</button>;\n}","methods#Methods":"the available methods in the selected account. (e.g. sign)\nType","disconnect#disconnect":"import { useCosmosAccount } from '@cosmostation/use-wallets';\nexport default function Account() {\n  const { data } = useCosmosAccount('cosmoshub-4');\n  return <button onClick={() => data?.method.disconnect()}>Disconnect</button>;\n}","signamino#signAmino":"Amino Doc Type\nimport { useCosmosAccount } from '@cosmostation/use-wallets';\nexport default function SignAmino() {\n  const { data } = useCosmosAccount('cosmoshub-4');\n  const sendExampleDoc = {\n    // ...\n  };\n  return (\n    <button\n      onClick={async () => {\n        try {\n          if (!data) {\n            throw new Error('No data');\n          }\n          console.dir(await data?.methods.signAmino(sendExampleDoc), { depth: 100 });\n        } catch (e) {\n          console.log(e.message);\n        }\n      }}\n    >\n      Sign Amino\n    </button>\n  );\n}","signdirect#signDirect":"Direct Doc Type\nimport { useCosmosAccount } from '@cosmostation/use-wallets';\nexport default function SignDirect() {\n  const { data } = useCosmosAccount('cosmoshub-4');\n  const sendExampleDoc = {\n    // ...\n  };\n  return (\n    <button\n      onClick={async () => {\n        try {\n          if (!data) {\n            throw new Error('No data');\n          }\n          const result = await data.methods.signDirect(sendExampleDoc);\n          console.dir(result, { depth: 100 });\n        } catch (e) {\n          console.log(e.message);\n        }\n      }}\n    >\n      Sign Direct\n    </button>\n  );\n}","signandsendtransaction#signAndSendTransaction":"A method that combines sign and send using signDirect\nReceives message as json and automates creation of protobufJSON e.g.\nimport { useCosmosAccount } from '@cosmostation/use-wallets';\nexport default function SignAndSendTransaction() {\n  const { data } = useCosmosAccount('cosmoshub-4');\n  return (\n    <Button\n      onClick={async () => {\n        try {\n          if (!data) {\n            throw new Error('No data');\n          }\n          console.dir(\n            await data?.methods.signAndSendTransaction({\n              messages: [\n                {\n                  type_url: '/cosmos.bank.v1beta1.MsgSend',\n                  value: {\n                    from_address: data?.account.address,\n                    to_address: data?.account.address,\n                    amount: [\n                      {\n                        denom: 'uatom',\n                        amount: '1',\n                      },\n                    ],\n                  },\n                },\n              ],\n              memo: 'Test (Sign And Send Transaction)',\n            }),\n            { depth: 100 },\n          );\n        } catch (e) {\n          console.log(e.message);\n        }\n      }}\n    >\n      Sign And Send Transaction\n    </Button>\n  );\n}","signmessage#signMessage":"sign arbitrary bytes\nimport { useCosmosAccount } from '@cosmostation/use-wallets';\nexport default function SignAndSendTransaction() {\n  const { data } = useCosmosAccount('cosmoshub-4');\n  return (\n    <Button\n      onClick={async () => {\n        try {\n          if (!data) {\n            throw new Error('No data');\n          }\n          if (!data.methods.signMessage) {\n            throw new Error('No signMessage method');\n          }\n          const message = '(test) sign message';\n          console.dir(await data.methods.signMessage(message));\n        } catch (e) {\n          console.log(e.message);\n        }\n      }}\n    >\n      Sign Message\n    </Button>\n  );\n}","verifymessage#verifyMessage":"verify arbitrary bytes\nimport { useCosmosAccount } from '@cosmostation/use-wallets';\nexport default function SignAndSendTransaction() {\n  const { data } = useCosmosAccount('cosmoshub-4');\n  return (\n    <Button\n      onClick={async () => {\n        try {\n          if (!data) {\n            throw new Error('No data');\n          }\n          if (!data.methods.signMessage) {\n            throw new Error('No signMessage method');\n          }\n          if (!data.methods.verifyMessage) {\n            throw new Error('No verifyMessage method');\n          }\n          const message = '(test) sign message';\n          const response = await data.methods.signMessage(message);\n          const verify = await data.methods.verifyMessage(message, response.signature);\n          console.log(verify ? 'verified' : 'not verified');\n        } catch (e) {\n          console.log(e.message);\n        }\n      }}\n    >\n      Verify Message\n    </Button>\n  );\n}","type#Type":"","account-1#Account":"interface Account {\n  data?: {\n    account: CosmosAccount;\n    methods: CosmosMethods;\n  };\n  error?: string;\n  mutate: () => void;\n}","cosmosaccount#CosmosAccount":"interface CosmosAccount {\n  address: string;\n  public_key: {\n    type: CosmosPublicKeyType;\n    value: string;\n  };\n  name?: string;\n  is_ledger?: boolean;\n}","cosmospublickeytype#CosmosPublicKeyType":"type CosmosPublicKeyType = 'secp256k1' | 'ethsecp256k1';","cosmosmethods#CosmosMethods":"interface CosmosMethods {\n  signAndSendTransaction: (\n    props: SignAndSendTransactionProps,\n    options?: SignOptions,\n  ) => Promise<CosmosSendTransactionResponse>;\n  signAmino: (\n    document: CosmosSignAminoDoc,\n    options?: SignOptions,\n  ) => Promise<CosmosSignAminoResponse>;\n  signDirect: (\n    document: CosmosSignDirectDoc,\n    options?: SignOptions,\n  ) => Promise<CosmosSignDirectResponse>;\n  sendTransaction: (\n    tx_bytes: Uint8Array | string,\n    mode?: number,\n  ) => Promise<CosmosSendTransactionResponse>;\n  getSupportedChainIds: () => Promise<string[]>;\n  signMessage?: (message: string, signer: string) => Promise<CosmosSignMessageResponse>;\n  verifyMessage?: (message: string, signature: string) => Promise<boolean>;\n}","cosmossignaminodoc#CosmosSignAminoDoc":"interface CosmosSignAminoDoc {\n  sequence: string;\n  account_number: string;\n  fee: {\n    amount?: {\n      denom: string;\n      amount: string;\n    }[];\n    gas: string;\n  };\n  memo: string;\n  msgs: {\n    type: string;\n    value: any;\n  }[];\n}","cosmossignaminoresponse#CosmosSignAminoResponse":"interface CosmosSignAminoResponse {\n  signature: string;\n  signed_doc: any;\n}","cosmossigndirectdoc#CosmosSignDirectDoc":"interface CosmosSignDirectDoc {\n  account_number: string;\n  body_bytes: string | Uint8Array;\n  auth_info_bytes: string | Uint8Array;\n}","cosmossigndirectresponse#CosmosSignDirectResponse":"interface CosmosSignDirectResponse {\n  signature: string;\n  signed_doc: CosmosSignedDoc;\n}","signandsendtransactionprops#SignAndSendTransactionProps":"interface CosmosSignAndSendTransactionProps {\n  messages: Message[];\n  memo?: string;\n  fee?: Fee;\n  sequence?: number;\n  lcd_url?: string;\n  fee_denom?: string;\n  gas_rate?: number;\n  payer?: string;\n  granter?: string;\n}\ninterface CosmosMessage {\n  type_url: string;\n  value?: unknown;\n}","cosmosfee#CosmosFee":"interface CosmosFee {\n  amount: Amount[];\n  gas_limit: number;\n  payer?: string;\n  granter?: string;\n}\ninterface CosmosAmount {\n  denom: string;\n  amount: number;\n}"}},"/extension/integration/cosmos/typescript":{"title":"Typescript","data":{"installation#Installation":"The Cosmostation wallet package lives in npm. To install the latest stable version, run the following command:\nnpm install @cosmostation/extension\nOr if you're using yarn:\nyarn add @cosmostation/extension","account#Account":"","request-account#Request account":"Get account information\nimport { cosmos } from '@cosmostation/extension';\n<button\n  onClick={async () => {\n    try {\n      const provider = await cosmos('cosmoshub-4');\n      const account = await provider.requestAccount();\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Request Account\n</button>;","disconnect#Disconnect":"Disconnect from the extension\nimport { cosmos } from '@cosmostation/extension';\n<button\n  onClick={async () => {\n    try {\n      const provider = await cosmos('cosmoshub-4');\n      const account = await provider.requestAccount();\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Disconnect\n</button>;","sign#Sign":"","signamino#SignAmino":"Signing with amino in the legacy way.\nimport { cosmos } from '@cosmostation/extension';\n<button\n  onClick={async () => {\n    try {\n      const provider = await cosmos('cosmoshub-4');\n      const doc = {\n        //  ...\n      };\n      const response = await provider.signAmino(doc);\n      console.log(response.signatures);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Sign Amino\n</button>;","signdirect#SignDirect":"Signing based on protobuf\nimport { cosmos } from '@cosmostation/extension';\n<button\n  onClick={async () => {\n    try {\n      const provider = await cosmos('cosmoshub-4');\n      const doc = {\n        //  ...\n      };\n      const response = await provider.signDirect(doc);\n      console.log(response.signatures);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Sign Direct\n</button>;","signandsendtransaction#SignAndSendTransaction":"A method that combines sign and send using signDirect\nReceives message as json and automates creation of protobufJSON e.g.\nimport { cosmos } from '@cosmostation/extension';\n<button\n  onClick={async () => {\n    try {\n      const provider = await cosmos('cosmoshub-4');\n      const account = await provider.requestAccount();\n      const response = await provider.signAndSendTransaction({\n        messages: [\n          {\n            type_url: '/cosmos.bank.v1beta1.MsgSend',\n            value: {\n              from_address: account.address,\n              to_address: account.address,\n              amount: [\n                {\n                  denom: 'uatom',\n                  amount: '1',\n                },\n              ],\n            },\n          },\n        ],\n        memo: 'Test (Sign And Send Transaction)',\n      });\n      console.log(response);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Sign And Send Transaction\n</button>;","signmessage#SignMessage":"sign arbitrary bytes\nimport { cosmos } from '@cosmostation/extension';\n<button\n  onClick={async () => {\n    try {\n      const provider = await cosmos('cosmoshub-4');\n      const response = await provider.signMessage('Test (Sign Message)');\n      console.log(response.signature);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Sign Message\n</button>;","verifymessage#verifyMessage":"verify arbitrary bytes\nimport { cosmos } from '@cosmostation/extension';\n<button\n  onClick={async () => {\n    try {\n      const provider = await cosmos('cosmoshub-4');\n      const text = 'Test (Sign Message)';\n      const signResponse = await provider.signMessage(text);\n      const verifyResponse = await provider.verifyMessage(text, signResponse.signature);\n      console.log(verifyResponse ? 'verified' : 'not verified');\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Sign & Verify Message\n</button>;","addcustomchain#AddCustomChain":"Add a chain or testnet chain that is not officially provided by the extension.\nimport { cosmosFunctions } from '@cosmostation/extension';\n<button\n  onClick={async () => {\n    try {\n      const response = cosmosFunctions.addCosmosChain({\n        chainId: 'custom-chain-1',\n        chainName: 'custom-chain',\n        addressPrefix: 'custom',\n        baseDenom: 'ucustom',\n        displayDenom: 'CUSTOM',\n        restURL: 'https://rpc.custom-chain.com',\n        decimals: 6, // optional\n        coinType: \"118'\", // optional\n      });\n      console.log(response.tx_response.txhash);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Add a custom chain\n</button>;","event#Event":"","addeventlistener#addEventListener":"window.addEventListener('cosmostation_keystorechange', () => {\n  console.log('Key store in Cosmostation is changed. You may need to refetch the account info.');\n});","removeeventlistener#removeEventListener":"window.removeEventListener('cosmostation_keystorechange', handler);"}},"/extension/integration/cosmos/proto":{"title":"Protobuf JSON","data":{"":"Automatically creates json as a transaction in protobuf format.\nWhen using signAndTransaction, send a message as shown below.This is an example. You can request it by filling in the value in [input].","test#Test":"You can test it by connecting directly to your wallet. Please refer to the example below and send a transaction.\nIt will be sent directly to the cosmoshub-4 mainnet, so don't sign if you don't want to.","1-connect#1. Connect":"","2-get-account#2. Get Account":"","3-sign-and-send-transaction#3. Sign And Send Transaction":"It is editable.\nYou can send multiple messages.","example#Example":"","send#Send":"{\n  \"type_url\": \"/cosmos.bank.v1beta1.MsgSend\",\n  \"value\": {\n    \"from_address\": \"from_address\", // [input]: string\n    \"to_address\": \"to_address\", // [input]: string\n    \"amount\": [\n      {\n        \"denom\": \"denom\", // [input]: string\n        \"amount\": \"amount\" // [input]: string\n      }\n    ]\n  }\n}","multisend#MultiSend":"{\n  \"type_url\": \"/cosmos.bank.v1beta1.MsgMultiSend\",\n  \"value\": {\n    \"inputs\": [\n      {\n        \"address\": \"address\", // [input]: string\n        \"coins\": [\n          {\n            \"denom\": \"denom\", // [input]: string\n            \"amount\": \"amount\" // [input]: string\n          }\n        ]\n      }\n    ],\n    \"outputs\": [\n      {\n        \"address\": \"address\", // [input]: string\n        \"coins\": [\n          {\n            \"denom\": \"denom\", // [input]: string\n            \"amount\": \"amount\" // [input]: string\n          }\n        ]\n      }\n    ]\n  }\n}","delegate#Delegate":"{\n  \"type_url\": \"/cosmos.staking.v1beta1.MsgDelegate\",\n  \"value\": {\n    \"delegator_address\": \"delegator_address\", // [input]: string\n    \"validator_address\": \"validator_address\", // [input]: string\n    \"amount\": {\n      \"denom\": \"denom\", // [input]: string\n      \"amount\": \"amount\" // [input]: string\n    }\n  }\n}","redelegate#Redelegate":"{\n  \"type_url\": \"/cosmos.staking.v1beta1.MsgBeginRedelegate\",\n  \"value\": {\n    \"delegator_address\": \"[input]\", // [input]: string\n    \"validator_src_address\": \"[input]\", // [input]: string\n    \"validator_dst_address\": \"[input]\", // [input]: string\n    \"amount\": {\n      \"denom\": \"[input]\", // [input]: string\n      \"amount\": \"[input]\" // [input]: string\n    }\n  }\n}","undelegate#Undelegate":"{\n  \"type_url\": \"/cosmos.staking.v1beta1.MsgUndelegate\",\n  \"value\": {\n    \"delegator_address\": \"delegator_address\", // [input]: string\n    \"validator_address\": \"validator_address\", // [input]: string\n    \"amount\": {\n      \"denom\": \"denom\", // [input]: string\n      \"amount\": \"amount\" // [input]: string\n    }\n  }\n}","reward#Reward":"{\n  \"type_url\": \"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\",\n  \"value\": {\n    \"delegator_address\": \"delegator_address\", // [input]: string\n    \"validator_address\": \"validator_address\" // [input]: string\n  }\n}","vote#Vote":"{\n  \"type_url\": \"/cosmos.gov.v1beta1.MsgVote\",\n  \"value\": {\n    \"proposal_id\": 823, // [input]: number\n    \"voter\": \"voter\", // [input]: string\n    \"option\": 1 // [input]: number (yes: 1, abstain: 2, no: 3, no_with_veto: 4)\n  }\n}","vote-options#Vote Options":"enum VoteOption {\n  VOTE_OPTION_UNSPECIFIED = 0,\n  VOTE_OPTION_YES = 1,\n  VOTE_OPTION_ABSTAIN = 2,\n  VOTE_OPTION_NO = 3,\n  VOTE_OPTION_NO_WITH_VETO = 4\n}","ibc-transfer#IBC Transfer":"{\n  \"type_url\": \"/ibc.applications.transfer.v1.MsgTransfer\",\n  \"value\": {\n    \"source_port\": \"source_port\", // [input]: string\n    \"source_channel\": \"source_channel\", // [input]: string\n    \"token\": {\n      \"denom\": \"denom\", // [input]: string\n      \"amount\": \"amount\" // [input]: string\n    },\n    \"sender\": \"sender\", // [input]: string\n    \"receiver\": \"receiver\", // [input]: string\n    \"timeout_height\": {\n      \"revision_height\": 13594714, // [input]: number\n      \"revision_number\": 2 // [input]: number\n    },\n    \"memo\": \"\" // [input]: string\n  }\n}","cosmwasm-executecontract#Cosmwasm ExecuteContract":"{\n  \"type_url\": \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n  \"value\": {\n    \"sender\": \"sender\", // [input]: string\n    \"contract\": \"contract\", // [input]: string\n    \"funds\": [], // [input]: unknown[]\n    \"msg\": [1, 2] // [input]: Buffer or Uint8Array\n  }\n}","proposal#Proposal":"","textproposal#TextProposal":"{\n  \"type_url\": \"/cosmos.gov.v1beta1.MsgSubmitProposal\",\n  \"value\": {\n    \"content\": {\n      \"type_url\": \"/cosmos.gov.v1beta1.TextProposal\",\n      \"value\": {\n        \"title\": \"title\", // [input]: string\n        \"description\": \"description\" // [input]: string\n      }\n    },\n    \"initial_deposit\": [\n      {\n        \"denom\": \"denom\", // [input]: string\n        \"amount\": \"amount\" // [input]: string\n      }\n    ],\n    \"proposer\": \"proposer\" // [input]: string\n  }\n}","clientupdateproposal#ClientUpdateProposal":"{\n  \"type_url\": \"/cosmos.gov.v1beta1.MsgSubmitProposal\",\n  \"value\": {\n    \"content\": {\n      \"type_url\": \"/ibc.core.client.v1.ClientUpdateProposal\",\n      \"value\": {\n        \"title\": \"title\", // [input]: string\n        \"description\": \"description\", // [input]: string\n        \"subject_client_id\": \"subject_client_id\", // [input]: string\n        \"substitute_client_id\": \"substitute_client_id\" // [input]: string\n      }\n    },\n    \"initial_deposit\": [],\n    \"proposer\": \"proposer\" // [input]: string\n  }\n}","communitypoolspendproposal#CommunityPoolSpendProposal":"{\n  \"type_url\": \"/cosmos.gov.v1beta1.MsgSubmitProposal\",\n  \"value\": {\n    \"content\": {\n      \"type_url\": \"/cosmos.distribution.v1beta1.CommunityPoolSpendProposal\",\n      \"value\": {\n        \"title\": \"title\", // [input]: string\n        \"description\": \"description\", // [input]: string\n        \"recipient\": \"recipient\", // [input]: string\n        \"amount\": [\n          {\n            \"denom\": \"denom\", // [input]: string\n            \"amount\": \"amount\" // [input]: string\n          }\n        ]\n      }\n    },\n    \"initial_deposit\": [\n      {\n        \"denom\": \"denom\", // [input]: string\n        \"amount\": \"amount\" // [input]: string\n      }\n    ],\n    \"proposer\": \"proposer\" // [input]: string\n  }\n}","parameterchangeproposal#ParameterChangeProposal":"{\n  \"type_url\": \"/cosmos.gov.v1beta1.MsgSubmitProposal\",\n  \"value\": {\n    \"content\": {\n      \"type_url\": \"/cosmos.params.v1beta1.ParameterChangeProposal\",\n      \"value\": {\n        \"title\": \"title\", // [input]: string\n        \"description\": \"description\", // [input]: string\n        \"changes\": [\n          {\n            \"subspace\": \"subspace\", // [input]: string\n            \"key\": \"key\", // [input]: string\n            \"value\": \"value\" // [input]: string\n          }\n        ]\n      }\n    },\n    \"initial_deposit\": [\n      {\n        \"denom\": \"denom\", // [input]: string\n        \"amount\": \"amount\" // [input]: string\n      }\n    ],\n    \"proposer\": \"proposer\" // [input]: string\n  }\n}","softwareupgradeproposal#SoftwareUpgradeProposal":"{\n  \"type_url\": \"/cosmos.gov.v1beta1.MsgSubmitProposal\",\n  \"value\": {\n    \"content\": {\n      \"type_url\": \"/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal\",\n      \"value\": {\n        \"title\": \"title\", // [input]: string\n        \"description\": \"description\", // [input]: string\n        \"plan\": {\n          \"name\": \"name\", // [input]: string\n          \"height\": \"height\", // [input]: string\n          \"info\": \"info\", // [input]: string\n          \"upgraded_client_state\": null // [input]: null or IAny\n        }\n      }\n    },\n    \"initial_deposit\": [\n      {\n        \"denom\": \"denom\", // [input]: string\n        \"amount\": \"amount\" // [input]: string\n      }\n    ],\n    \"proposer\": \"proposer\" // [input]: string\n  }\n}","grant#Grant":"","delegate-grant#Delegate Grant":"{\n  \"type_url\": \"/cosmos.authz.v1beta1.MsgGrant\",\n  \"value\": {\n    \"granter\": \"granter\", // [input]: string\n    \"grantee\": \"grantee\", // [input]: string\n    \"grant\": {\n      \"authorization\": {\n        \"type_url\": \"/cosmos.staking.v1beta1.StakeAuthorization\",\n        \"value\": {\n          \"allow_list\": {\n            \"address\": [\"address\", \"address\"] // [input]: string[]\n          },\n          \"authorization_type\": 1 // [input]: number\n        }\n      },\n      \"expiration\": {\n        \"type_url\": \"/google.protobuf.Timestamp\",\n        \"value\": {\n          \"seconds\": 5325252355 // [input]: number (unix time)\n        }\n      }\n    }\n  }\n}","revoke-delegate-grant#Revoke Delegate Grant":"{\n  \"type_url\": \"/cosmos.authz.v1beta1.MsgRevoke\",\n  \"value\": {\n    \"granter\": \"granter\", // [input]: string\n    \"grantee\": \"grantee\", // [input]: string\n    \"msg_type_url\": \"/cosmos.staking.v1beta1.MsgDelegate\"\n  }\n}","authorization-type#Authorization Type":"type AuthorizationType = {\n    AUTHORIZATION_TYPE_UNSPECIFIED = 0,\n    AUTHORIZATION_TYPE_DELEGATE = 1,\n    AUTHORIZATION_TYPE_UNDELEGATE = 2,\n    AUTHORIZATION_TYPE_REDELEGATE = 3\n}"}},"/extension/integration/evm/event":{"title":"Event","data":{"accountschanged#accountsChanged":"If current account is connected to the dApp, return an array of address. Otherwise, return an empty array.\nimport { ethers } from \"ethers\";\nimport { ethereum, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await ethereum();\n  const handler = provider.on(\"accountsChanged\", (accounts) => {\n    if(accounts.length === 0 ) {\n      console.log(provider.request({'eth_requestAccounts'}))\n    } else {\n      console.log(accounts)\n    }\n  });\n  provider.off(handler)\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  // exception\n}","chainchanged#chainChanged":"import { ethers } from \"ethers\";\nimport { ethereum, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await ethereum();\n  const handler = provider.on(\"chainChanged\", (chainId) => {\n    console.log(chainId);\n  });\n  provider.off(handler);\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  // exception\n}"}},"/extension/integration/evm/provider":{"title":"Provider","data":{"":"Cosmostation extension support various chains.","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"import { ethereum, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await ethereum();\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n}","vanilla-code#Vanilla Code":"const ethereum = () => {\n  if (\"cosmostation\" in window) {\n    return window.cosmostation.ethereum;\n  } else {\n    window.open(\"https://cosmostation.io/wallet/#extension\");\n    /**\n     * or window.open(\"https://chrome.google.com/webstore/detail/cosmostation/fpkhgmpbidmiogeglndfbkegfdlnajnf\");\n     * */\n  }\n};\nconst provider = ethereum();"}},"/extension/integration/evm/supported-rpc-methods":{"title":"Supported RPC methods","data":{"ethereum-json-rpc-methods#Ethereum JSON-RPC Methods":"For the Ethereum JSON-RPC API, please see the Ethereum wikiImportant methods from this API include:\neth_accounts\neth_call\neth_getBalance\neth_sign\neth_sendTransaction\neth_signTransaction","eth_requestaccounts-eip-1102#eth_requestAccounts (EIP-1102)":"Link","returns#Returns":"string[] - An array of a single, hexadecimal Ethereum address string.","example#Example":"// provider.request or\nwindow.cosmostation.ethereum.request({\n  method: \"eth_requestAccounts\",\n});","wallet_addethereumchain-eip-3085#wallet_addEthereumChain (EIP-3085)":"Link","parameters#Parameters":"type WalletAddEthereumChainParam = [\n  {\n    chainId: string;\n    chainName: string;\n    blockExplorerUrls?: string[];\n    iconUrls?: string[];\n    nativeCurrency: {\n      name: string;\n      symbol: string;\n      decimals: number;\n    };\n    rpcUrls: string[];\n    coinGeckoId?: string;\n  }\n];","returns-1#Returns":"null - The method returns null if the request was successful, and an error otherwise.","example-1#Example":"// provider.request or\nwindow.cosmostation.ethereum.request({\n  method: \"wallet_addEthereumChain\",\n  params: [\n    {\n      chainId: \"0x38\",\n      chainName: \"Binance Smart Chain\",\n      rpcUrls: [\"https://bsc-dataseed.binance.org\"],\n      iconUrls: [\n        \"https://www.coinreaders.com/imgdata/coinreaders_com/202107/2021072701234398.png\",\n      ],\n      nativeCurrency: {\n        name: \"BNB\",\n        symbol: \"BNB\",\n        decimals: 18,\n      },\n      blockExplorerUrls: [\"https://bscscan.com\"],\n    },\n  ],\n});","wallet_switchethereumchain-eip-3326#wallet_switchEthereumChain (EIP-3326)":"Link","parameters-1#Parameters":"type WalletSwitchEthereumChainParam = [\n  {\n    chainId: string;\n  }\n];","returns-2#Returns":"null - The method returns null if the request was successful, and an error otherwise.","example-2#Example":"// provider.request or\nwindow.cosmostation.ethereum.request({\n  method: \"wallet_switchEthereumChain\",\n  params: [{ chainId: \"0x38\" }],\n});","wallet_watchasset-eip-747#wallet_watchAsset (EIP-747)":"Link","parameters-2#Parameters":"type WalletWatchAssetParam = {\n  type: string;\n  options: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    image?: string;\n    coinGeckoId?: string;\n  };\n};","returns-3#Returns":"boolean - true if the request was successful, error otherwise.","example-3#Example":"// provider.request or\nwindow.cosmostation.ethereum.request({\n  method: \"wallet_watchAsset\",\n  params: {\n    type: \"ERC20\",\n    options: {\n      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n      symbol: \"WETH\",\n      decimals: 18,\n    },\n  },\n});","eth_signtypeddata_v3--eth_signtypeddata_v4#eth_signTypedData_v3 / eth_signTypedData_v4":"","example-4#Example":"const msgParams = JSON.stringify({\n  domain: {\n    // Defining the chain aka Rinkeby testnet or Ethereum Main Net\n    chainId: 1,\n    // Give a user friendly name to the specific contract you are signing for.\n    name: \"Ether Mail\",\n    // If name isn't enough add verifying contract to make sure you are establishing contracts with the proper entity\n    verifyingContract: \"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC\",\n    // Just let's you know the latest version. Definitely make sure the field name is correct.\n    version: \"1\",\n  },\n  // Defining the message signing data content.\n  message: {\n    /*\n         - Anything you want. Just a JSON Blob that encodes the data you want to send\n         - No required fields\n         - This is DApp Specific\n         - Be as explicit as possible when building out the message schema.\n        */\n    contents: \"Hello, Bob!\",\n    attachedMoneyInEth: 4.2,\n    from: {\n      name: \"Cow\",\n      wallets: [\n        \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\",\n        \"0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF\",\n      ],\n    },\n    to: [\n      {\n        name: \"Bob\",\n        wallets: [\n          \"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\",\n          \"0xB0BdaBea57B0BDABeA57b0bdABEA57b0BDabEa57\",\n          \"0xB0B0b0b0b0b0B000000000000000000000000000\",\n        ],\n      },\n    ],\n  },\n  // Refers to the keys of the *types* object below.\n  primaryType: \"Mail\",\n  types: {\n    // TODO: Clarify if EIP712Domain refers to the domain the contract is hosted on\n    EIP712Domain: [\n      { name: \"name\", type: \"string\" },\n      { name: \"version\", type: \"string\" },\n      { name: \"chainId\", type: \"uint256\" },\n      { name: \"verifyingContract\", type: \"address\" },\n    ],\n    // Not an EIP712Domain definition\n    Group: [\n      { name: \"name\", type: \"string\" },\n      { name: \"members\", type: \"Person[]\" },\n    ],\n    // Refer to PrimaryType\n    Mail: [\n      { name: \"from\", type: \"Person\" },\n      { name: \"to\", type: \"Person[]\" },\n      { name: \"contents\", type: \"string\" },\n    ],\n    // Not an EIP712Domain definition\n    Person: [\n      { name: \"name\", type: \"string\" },\n      { name: \"wallets\", type: \"address[]\" },\n    ],\n  },\n});\nconst from = \"\"; // signer address\nconst params = [from, msgParams];\nconst method = \"eth_signTypedData_v4\";\n// provider.request or\nwindow.cosmostation.ethereum.request({\n  method,\n  params,\n});"}},"/extension/integration/evm/use-ethers":{"title":"Use ethers","data":{"":"npmjs\ndocs\nimport { ethers } from \"ethers\";\nimport { ethereum, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await ethereum();\n  const ethersProvider = new ethers.providers.Web3Provider(provider);\n  // requestAccounts\n  const accounts = ethersProvider.send(\"eth_requestAccounts\", []);\n  // If you want more info, please check out ethers docs (https://docs.ethers.io)\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  // exception\n}"}},"/extension/integration/evm/use-web3-js":{"title":"Use web3.js","data":{"":"npmjs\ndocs\nimport Web3 from \"web3\";\nimport { ethereum, InstallError } from \"@cosmostation/extension-client\";\ntry {\n  const provider = await ethereum();\n  const web3 = new Web3(provider);\n  // requestAccounts\n  const accounts = web3.eth.requestAccounts();\n  // If you want more info, please check out web3.js docs (https://web3js.readthedocs.io)\n} catch (e) {\n  if (e instanceof InstallError) {\n    console.log(\"not installed\");\n  }\n  // exception\n}","signtypeddata#signTypedData":"const provider = await ethereum();\nconst web3 = new Web3(provider);\nconst msgParams = JSON.stringify({\n  domain: {\n    // Defining the chain aka Rinkeby testnet or Ethereum Main Net\n    chainId: 1,\n    // Give a user friendly name to the specific contract you are signing for.\n    name: \"Ether Mail\",\n    // If name isn't enough add verifying contract to make sure you are establishing contracts with the proper entity\n    verifyingContract: \"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC\",\n    // Just let's you know the latest version. Definitely make sure the field name is correct.\n    version: \"1\",\n  },\n  // Defining the message signing data content.\n  message: {\n    /*\n         - Anything you want. Just a JSON Blob that encodes the data you want to send\n         - No required fields\n         - This is DApp Specific\n         - Be as explicit as possible when building out the message schema.\n        */\n    contents: \"Hello, Bob!\",\n    attachedMoneyInEth: 4.2,\n    from: {\n      name: \"Cow\",\n      wallets: [\n        \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\",\n        \"0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF\",\n      ],\n    },\n    to: [\n      {\n        name: \"Bob\",\n        wallets: [\n          \"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\",\n          \"0xB0BdaBea57B0BDABeA57b0bdABEA57b0BDabEa57\",\n          \"0xB0B0b0b0b0b0B000000000000000000000000000\",\n        ],\n      },\n    ],\n  },\n  // Refers to the keys of the *types* object below.\n  primaryType: \"Mail\",\n  types: {\n    // TODO: Clarify if EIP712Domain refers to the domain the contract is hosted on\n    EIP712Domain: [\n      { name: \"name\", type: \"string\" },\n      { name: \"version\", type: \"string\" },\n      { name: \"chainId\", type: \"uint256\" },\n      { name: \"verifyingContract\", type: \"address\" },\n    ],\n    // Not an EIP712Domain definition\n    Group: [\n      { name: \"name\", type: \"string\" },\n      { name: \"members\", type: \"Person[]\" },\n    ],\n    // Refer to PrimaryType\n    Mail: [\n      { name: \"from\", type: \"Person\" },\n      { name: \"to\", type: \"Person[]\" },\n      { name: \"contents\", type: \"string\" },\n    ],\n    // Not an EIP712Domain definition\n    Person: [\n      { name: \"name\", type: \"string\" },\n      { name: \"wallets\", type: \"address[]\" },\n    ],\n  },\n});\nconst from = \"\"; // signer address\nconst params = [from, msgParams];\nconst method = \"eth_signTypedData_v4\";\nconst result = web3.currentProvider.request({\n  method,\n  params,\n});"}},"/extension/integration/cosmos/vanilla":{"title":"Vanilla","data":{"":"This code can be used without any installation.","account#Account":"Get account information\n<button\n  onClick={async () => {\n    try {\n      if (!window.cosmostation) {\n        throw new Error('Cosmostation extension not installed');\n      }\n      const account = await window.cosmostation.cosmos.request({\n        method: 'cos_requestAccount',\n        params: { chainName: 'cosmoshub-4' },\n      });\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Request Account\n</button>","sign#Sign":"","signamino#SignAmino":"Signing with amino in the legacy way.\n<button\n  onClick={async () => {\n    try {\n      if (!window.cosmostation) {\n        throw new Error('Cosmostation extension not installed');\n      }\n      const doc = {\n        //...\n      };\n      const response = await window.cosmostation.cosmos.request({\n        method: 'cos_signAmino',\n        params: { chainName: 'cosmoshub-4', doc },\n      });\n      console.log(response.signature);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Sign Amino\n</button>","signdirect#SignDirect":"Signing based on protobuf\n<button\n  onClick={async () => {\n    try {\n      if (!window.cosmostation) {\n        throw new Error('Cosmostation extension not installed');\n      }\n      const doc = {\n        //  ...\n      };\n      const response = await window.cosmostation.cosmos.request({\n        method: 'cos_signDirect',\n        params: {\n          chainName: 'cosmoshub-4',\n          doc,\n        },\n      });\n      console.log(response.signatures);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Sign Direct\n</button>","signmessage#SignMessage":"sign arbitrary bytes\n<button\n  onClick={async () => {\n    try {\n      if (!window.cosmostation) {\n        throw new Error('Cosmostation extension not installed');\n      }\n      const account = await window.cosmostation.cosmos.request({\n        method: 'cos_requestAccount',\n        params: { chainName: 'cosmoshub-4' },\n      });\n      const response = await window.cosmostation.cosmos.request({\n        method: 'cos_signMessage',\n        params: {\n          chainName: 'cosmoshub-4',\n          message: 'Test (Sign Message)',\n          signer: account.address,\n        },\n      });\n      console.log(response.signature);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Sign Message\n</button>","verifymessage#VerifyMessage":"verify arbitrary bytes\n<button\n  onClick={async () => {\n    try {\n      if (!window.cosmostation) {\n        throw new Error('Cosmostation extension not installed');\n      }\n      const message = 'Test (Sign Message)';\n      const account = await window.cosmostation.cosmos.request({\n        method: 'cos_requestAccount',\n        params: { chainName: 'cosmoshub-4' },\n      });\n      const signResponse = await window.cosmostation.cosmos.request({\n        method: 'cos_signMessage',\n        params: {\n          chainName: 'cosmoshub-4',\n          message,\n          signer: account.address,\n        },\n      });\n      const verifyResponse = await window.cosmostation.cosmos.request({\n        method: 'cos_verifyMessage',\n        params: {\n          chainName: 'cosmoshub-4',\n          message,\n          signer: account.address,\n          publicKey: signResponse.pub_key.value,\n          signature: signResponse.signature,\n        },\n      });\n      console.log(verifyResponse ? 'verified' : 'not verified');\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Sign & Verify Message\n</button>","addcw20token#AddCW20Token":"<button\n  onClick={async () => {\n    try {\n      if (!window.cosmostation) {\n        throw new Error('Cosmostation extension not installed');\n      }\n      await window.cosmostation.cosmos.request({\n        method: 'cos_addTokensCW20',\n        params: {\n          chainName: 'juno-1',\n          tokens: [\n            {\n              contractAddress: '',\n            },\n          ],\n        },\n      });\n      console.log('added');\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Add CW20 Tokens\n</button>","addcustomchain#AddCustomChain":"Add a chain or testnet chain that is not officially provided by the extension.\n<button\n  onClick={async () => {\n    try {\n      if (!window.cosmostation) {\n        throw new Error('Cosmostation extension not installed');\n      }\n      const response = await window.cosmostation.cosmos.request({\n        method: 'cos_addChain',\n        params: {\n          chainId: 'custom-chain-1',\n          chainName: 'custom-chain',\n          addressPrefix: 'custom',\n          baseDenom: 'ucustom',\n          displayDenom: 'CUSTOM',\n          restURL: 'https://rpc.custom-chain.com',\n          decimals: 6, // optional\n          coinType: '118', // optional\n        },\n      });\n      console.log(response.tx_response.txhash);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }}\n>\n  Add a custom chain\n</button>","event#Event":"","addeventlistener#addEventListener":"window.addEventListener('cosmostation_keystorechange', () => {\n  console.log('Key store in Cosmostation is changed. You may need to refetch the account info.');\n});","removeeventlistener#removeEventListener":"window.removeEventListener('cosmostation_keystorechange', handler);"}},"/extension/integration/sui/connect-and-get-accounts":{"title":"Connect And Get Accounts","data":{"":"connect and get Account via Cosmostation Extension\nconst response = await window.cosmostation.sui.connect();\n// or\nconst response = await window.cosmostation.sui.connect([\n  \"viewAccount\",\n  \"suggestTransactions\",\n]);","response#Response":"export type SuiConnectResponse = boolean;\ntrue","get-accounts#Get Accounts":"","vanilla-code#Vanilla Code":"const response = await window.cosmostation.sui.connect();\nconst accounts = await window.cosmostation.sui.getAccounts();\nconst publicKey = await window.cosmostation.sui.getPublicKey();","response-1#Response":"export type SuiAccountResponse = string[];\n[\"0xd2d030d4339531d9cb442caf4be7bb954fddedb4\"]"}},"/extension/integration/sui/sign-and-execute-transaction":{"title":"Sign And Execute Transaction","data":{"":"import { TransactionBlock } from \"@mysten/sui.js\";\n// Send Sui coin\nconst tx = new TransactionBlock();\nconst sampleSendCoinAmount = \"100000\";\nconst sampleReceiverAddress = \"0x...\";\nconst [coin] = tx.splitCoins(tx.gas, [tx.pure(sampleSendCoinAmount)]);\ntx.transferObjects([coin], tx.pure(sampleReceiverAddress));\n// SuiSignAndExecuteTransactionBlockInput\nconst payload = {\n  transactionBlock: tx,\n  options: {\n    showInput: true,\n    showEffects: true,\n    showEvents: true,\n  },\n};\nawait window.cosmostation.sui.connect();\nconst response = await window.cosmostation.sui.signAndExecuteTransaction(\n  payload\n);","request#request":"SuiSignAndExecuteTransactionBlockInput\nexport interface SuiSignTransactionBlockInput {\n  transactionBlock: TransactionBlock;\n  account: WalletAccount;\n  chain: IdentifierString;\n}\nexport interface SuiSignAndExecuteTransactionBlockInput\n  extends SuiSignTransactionBlockInput {\n  requestType?: ExecuteTransactionRequestType;\n  options?: SuiTransactionBlockResponseOptions;\n}\nexport type SuiTransactionBlockResponseOptions = {\n  showInput?: boolean | undefined;\n  showEffects?: boolean | undefined;\n  showEvents?: boolean | undefined;\n  showObjectChanges?: boolean | undefined;\n  showBalanceChanges?: boolean | undefined;\n};","response#Response":"SuiTransactionResponse\nSuiTransactionBlock\nTransactionEffects\nTransactionEvents\nSuiObjectChange\nBalanceChange\nexport type SuiTransactionResponse = {\n  digest: TransactionDigest,\n  transaction: optional(SuiTransactionBlock),\n  effects: optional(TransactionEffects),\n  events: optional(TransactionEvents),\n  timestampMs: optional(string()),\n  checkpoint: optional(string()),\n  confirmedLocalExecution: optional(boolean()),\n  objectChanges: optional(array(SuiObjectChange)),\n  balanceChanges: optional(array(BalanceChange)),\n  /* Errors that occurred in fetching/serializing the transaction. */\n  errors: optional(array(string())),\n};\n{\n  \"digest\": \"ADxukibq4o4QqiMgr6QqtXnXczh5MGCQqMkgCKUW5NXT\",\n  \"transaction\": {\n    \"data\": {\n      \"messageVersion\": \"v1\",\n      \"transaction\": {\n        \"kind\": \"ProgrammableTransaction\",\n        \"inputs\": [\n          {\n            \"type\": \"pure\",\n            \"valueType\": \"u64\",\n            \"value\": \"1000000000\"\n          },\n          {\n            \"type\": \"object\",\n            \"objectType\": \"sharedObject\",\n            \"objectId\": \"\",\n            \"initialSharedVersion\": \"1\",\n            \"mutable\": true\n          },\n          {\n            \"type\": \"pure\",\n            \"valueType\": \"address\",\n            \"value\": \"\"\n          }\n        ],\n        \"transactions\": [\n          {\n            \"SplitCoins\": [\n              \"GasCoin\",\n              [\n                {\n                  \"Input\": 0\n                }\n              ]\n            ]\n          },\n          {\n            \"MoveCall\": {\n              \"package\": \"\",\n              \"module\": \"sui_system\",\n              \"function\": \"request_add_stake\",\n              \"arguments\": [\n                {\n                  \"Input\": 1\n                },\n                {\n                  \"Result\": 0\n                },\n                {\n                  \"Input\": 2\n                }\n              ]\n            }\n          }\n        ]\n      },\n      \"sender\": \"\",\n      \"gasData\": {\n        \"payment\": [\n          {\n            \"objectId\": \"\",\n            \"version\": 120,\n            \"digest\": \"4eWN3j13gkCgmpF3ino3PyBnBGcr8TM9g7oXyLVcFvDf\"\n          }\n        ],\n        \"owner\": \"\",\n        \"price\": \"990\",\n        \"budget\": \"10269000\"\n      }\n    },\n    \"txSignatures\": [\n      \"AOM7i8tZRt314VYWxtBr5DAUukOZJsRcX6YUZjKVzB/j0gyYqCMZ1mIVPFdM79VNXzEpS2Te8Ez7g878a13Ybwz6TRHL+z8z7uHmh38YqSzeZTJS1AuOfKSpuon1IV17MQ==\"\n    ]\n  },\n  \"effects\": {\n    \"messageVersion\": \"v1\",\n    \"status\": {\n      \"status\": \"success\"\n    },\n    \"executedEpoch\": \"25\",\n    \"gasUsed\": {\n      \"computationCost\": \"990000\",\n      \"storageCost\": \"721559200\",\n      \"storageRebate\": \"713064528\",\n      \"nonRefundableStorageFee\": \"7202672\"\n    },\n    \"modifiedAtVersions\": [\n      {\n        \"objectId\": \"\",\n        \"sequenceNumber\": \"1999135\"\n      },\n      {\n        \"objectId\": \"\",\n        \"sequenceNumber\": \"1999135\"\n      },\n      {\n        \"objectId\": \"\",\n        \"sequenceNumber\": \"120\"\n      }\n    ],\n    \"sharedObjects\": [\n      {\n        \"objectId\": \"\",\n        \"version\": 1999135,\n        \"digest\": \"DwbUaKPdp58kXHhh3WGzSnxv1uuzoEP55mmvrZyRqx8Q\"\n      }\n    ],\n    \"transactionDigest\": \"ADxukibq4o4QqiMgr6QqtXnXczh5MGCQqMkgCKUW5NXT\",\n    \"created\": [\n      {\n        \"owner\": {\n          \"AddressOwner\": \"\"\n        },\n        \"reference\": {\n          \"objectId\": \"\",\n          \"version\": 1999136,\n          \"digest\": \"BEEN82jwzg2gku5meXogNQLz1zSnbv9rEFRVu7RhekPd\"\n        }\n      }\n    ],\n    \"mutated\": [\n      {\n        \"owner\": {\n          \"Shared\": {\n            \"initial_shared_version\": 1\n          }\n        },\n        \"reference\": {\n          \"objectId\": \"\",\n          \"version\": 1999136,\n          \"digest\": \"CgnEEDYNDnAyFb6GzXwvCTC5X1RqAUEGkLQN59dn86Fn\"\n        }\n      },\n      {\n        \"owner\": {\n          \"ObjectOwner\": \"\"\n        },\n        \"reference\": {\n          \"objectId\": \"\",\n          \"version\": 1999136,\n          \"digest\": \"7zdHAR9jtbEuaNroxVUUXGgMBJCVF9RRfQ1ACy4sGr8d\"\n        }\n      },\n      {\n        \"owner\": {\n          \"AddressOwner\": \"\"\n        },\n        \"reference\": {\n          \"objectId\": \"\",\n          \"version\": 1999136,\n          \"digest\": \"4uYp4yEhf4kcKmdUSZmxao5nGo38mydK93w9Vj6GdmJy\"\n        }\n      }\n    ],\n    \"gasObject\": {\n      \"owner\": {\n        \"AddressOwner\": \"\"\n      },\n      \"reference\": {\n        \"objectId\": \"\",\n        \"version\": 1999136,\n        \"digest\": \"4uYp4yEhf4kcKmdUSZmxao5nGo38mydK93w9Vj6GdmJy\"\n      }\n    },\n    \"eventsDigest\": \"5MMMagM2CoBtWGL7x39i2H8FeF75LWfFzgZDpzc5YC1H\",\n    \"dependencies\": [\n      \"Ui22Hhc6NyVEnAhRWCWVT333JvvBWG75qJx9qBg9VE1\",\n      \"53k4PWPByFxMLEYu53coAPiFCoxoz1mkUnv2Nr73UFw1\",\n      \"6oLy1FVtkMhuknWGsz7cvyYhn5CZFGPnyLhXZYuBd8kh\"\n    ]\n  },\n  \"events\": [\n    {\n      \"id\": {\n        \"txDigest\": \"ADxukibq4o4QqiMgr6QqtXnXczh5MGCQqMkgCKUW5NXT\",\n        \"eventSeq\": \"0\"\n      },\n      \"packageId\": \"\",\n      \"transactionModule\": \"sui_system\",\n      \"sender\": \"\",\n      \"type\": \"0x3::validator::StakingRequestEvent\",\n      \"parsedJson\": {\n        \"amount\": \"1000000000\",\n        \"epoch\": \"25\",\n        \"pool_id\": \"\",\n        \"staker_address\": \"\",\n        \"validator_address\": \"\"\n      },\n      \"bcs\": \"\"\n    }\n  ],\n  \"confirmedLocalExecution\": true\n}"}},"/extension/integration/cosmos/wallet":{"title":"Wallet","data":{"":"The interface of each Cosmos wallet is different, and in order to solve the problem of having to manually attach each wallet to the Dapp, it was developed to automatically add the same interface and wallet.","installation#Installation":"npm install @cosmostation/wallets\nOr if you're using yarn:\nyarn add @cosmostation/wallets","add-wallet#Add Wallet":"To detect a wallet, it is ideal to inject it directly from the extension, but it is also possible to manually inject a wallet that has not been injected into a dapp.Example\nimport { registerCosmosWallet, CosmosRegisterWallet } from '@cosmostation/wallets';\n<button\n  onClick={() => {\n    const wallet: CosmosRegisterWallet = {\n      // ...\n    };\n    registerCosmosWallet(wallet);\n  }}\n>\n  Register Wallet\n</button>;\ngo to test","example#Example":"This is an example of adding keplr and leap wallet.","keplr#Keplr":"import { registerCosmosWallet, CosmosRegisterWallet } from '@cosmostation/wallets';\n<button\n  onClick={() => {\n    if (!window.keplr) {\n      alert('Keplr extension is not installed');\n      return;\n    }\n    const wallet: CosmosRegisterWallet = {\n      name: 'Keplr',\n      logo: 'https://wallet.keplr.app/keplr-brand-assets/keplr-logo.svg',\n      events: {\n        on(type, listener) {\n          if (type === 'AccountChanged') {\n            window.addEventListener('keplr_keystorechange', listener);\n          }\n        },\n        off(type, listener) {\n          if (type === 'AccountChanged') {\n            window.removeEventListener('keplr_keystorechange', listener);\n          }\n        },\n      },\n      methods: {\n        getSupportedChainIds: async () => {\n          return ['cosmoshub-4'];\n        },\n        connect: async (chainIds) => {\n          const cIds = typeof chainIds === 'string' ? [chainIds] : chainIds;\n          const supportedChainIds = await wallet.methods.getSupportedChainIds();\n          if (!cIds.every((cId) => supportedChainIds.includes(cId))) {\n            throw new Error('Unsupported chainId is exist');\n          }\n          await window.keplr.enable(chainIds);\n        },\n        getAccount: async (chainId) => {\n          const response = await window.keplr.getKey(chainId);\n          return {\n            address: response.bech32Address,\n            name: response.name,\n            public_key: {\n              type: response.algo,\n              value: Buffer.from(response.pubKey).toString('base64'),\n            },\n            is_ledger: response.isNanoLedger,\n          };\n        },\n        signAmino: async (chainId, document, options) => {\n          if (typeof options?.edit_mode?.fee === 'boolean') {\n            window.keplr.defaultOptions.sign.preferNoSetFee = options.edit_mode.fee;\n          }\n          if (typeof options?.edit_mode?.memo === 'boolean') {\n            window.keplr.defaultOptions.sign.preferNoSetMemo = options.edit_mode.memo;\n          }\n          if (typeof options?.is_check_balance === 'boolean') {\n            window.keplr.defaultOptions.sign.disableBalanceCheck = options.is_check_balance;\n          }\n          const signer = options?.signer || (await wallet.methods.getAccount(chainId)).address;\n          const response = await window.keplr.signAmino(chainId, signer, document);\n          return {\n            signature: response.signature.signature,\n            signed_doc: response.signed,\n          };\n        },\n        signDirect: async (chainId, document, options) => {\n          if (typeof options?.edit_mode?.fee === 'boolean') {\n            window.keplr.defaultOptions.sign.preferNoSetFee = options.edit_mode.fee;\n          }\n          if (typeof options?.edit_mode?.memo === 'boolean') {\n            window.keplr.defaultOptions.sign.preferNoSetMemo = options.edit_mode.memo;\n          }\n          if (typeof options?.is_check_balance === 'boolean') {\n            window.keplr.defaultOptions.sign.disableBalanceCheck = !options.is_check_balance;\n          }\n          const account = await wallet.methods.getAccount(chainId);\n          if (account.is_ledger) {\n            throw new Error('Ledger is not supported');\n          }\n          const signer = options?.signer || account.address;\n          const signingDoc = {\n            accountNumber: document.account_number,\n            authInfoBytes: document.auth_info_bytes,\n            chainId: document.chain_id,\n            bodyBytes: document.body_bytes,\n          };\n          const response = await window.keplr.signDirect(chainId, signer, signingDoc);\n          return {\n            signature: response.signature.signature,\n            signed_doc: {\n              auth_info_bytes: response.signed.authInfoBytes,\n              body_bytes: response.signed.bodyBytes,\n            },\n          };\n        },\n        sendTransaction: async (chainId, tx_bytes, mode) => {\n          const broadcastMode =\n            mode === 1 ? 'block' : mode === 2 ? 'sync' : mode === 3 ? 'async' : 'sync';\n          const txBytes =\n            typeof tx_bytes === 'string'\n              ? new Uint8Array(Buffer.from(tx_bytes, 'base64'))\n              : tx_bytes;\n          const response = await window.keplr.sendTx(chainId, txBytes, broadcastMode);\n          const txHash = Buffer.from(response).toString('hex').toUpperCase();\n          return txHash;\n        },\n        addChain: async (chain) => {\n          const coinType = chain.coin_type ? Number(chain.coin_type.replaceAll(\"'\", '')) : 118;\n          await window.keplr.experimentalSuggestChain({\n            chainId: chain.chain_id,\n            chainName: chain.chain_name,\n            rpc: chain.lcd_url,\n            rest: chain.lcd_url,\n            bip44: {\n              coinType,\n            },\n            bech32Config: {\n              bech32PrefixAccAddr: chain.address_prefix,\n              bech32PrefixAccPub: chain.address_prefix + 'pub',\n              bech32PrefixValAddr: chain.address_prefix + 'valoper',\n              bech32PrefixValPub: chain.address_prefix + 'valoperpub',\n              bech32PrefixConsAddr: chain.address_prefix + 'valcons',\n              bech32PrefixConsPub: chain.address_prefix + 'valconspub',\n            },\n            currencies: [\n              {\n                coinDenom: chain.display_denom,\n                coinMinimalDenom: chain.base_denom,\n                coinDecimals: chain.decimals || 6,\n                coinGeckoId: chain.coingecko_id || 'unknown',\n              },\n            ],\n            feeCurrencies: [\n              {\n                coinDenom: chain.display_denom,\n                coinMinimalDenom: chain.base_denom,\n                coinDecimals: chain.decimals || 6,\n                coinGeckoId: chain.coingecko_id || 'unknown',\n                gasPriceStep: {\n                  low: chain?.gas_rate?.tiny ? Number(chain?.gas_rate?.tiny) : 0.01,\n                  average: chain?.gas_rate?.low ? Number(chain?.gas_rate?.low) : 0.025,\n                  high: chain?.gas_rate?.average ? Number(chain?.gas_rate?.average) : 0.04,\n                },\n              },\n            ],\n            stakeCurrency: {\n              coinDenom: chain.display_denom,\n              coinMinimalDenom: chain.base_denom,\n              coinDecimals: chain.decimals || 6,\n              coinGeckoId: chain.coingecko_id || 'unknown',\n            },\n          });\n        },\n      },\n    };\n    registerCosmosWallet(wallet);\n  }}\n>\n  Register Keplr Wallet\n</button>;","leap#Leap":"import { registerCosmosWallet, CosmosRegisterWallet } from '@cosmostation/wallets';\n<button\n  onClick={() => {\n    if (!window.leap) {\n      alert('Leap extension is not installed');\n      return;\n    }\n    const wallet: CosmosRegisterWallet = {\n      name: 'Leap',\n      logo: 'https://miro.medium.com/v2/resize:fill:176:176/1*2jNLyjIPuU8HBbayPapwcQ.png',\n      events: {\n        on(type, listener) {\n          if (type === 'AccountChanged') {\n            window.addEventListener('leap_keystorechange', listener);\n          }\n        },\n        off(type, listener) {\n          if (type === 'AccountChanged') {\n            window.removeEventListener('leap_keystorechange', listener);\n          }\n        },\n      },\n      methods: {\n        getSupportedChainIds: async () => {\n          return ['cosmoshub-4'];\n        },\n        connect: async (chainIds) => {\n          const cIds = typeof chainIds === 'string' ? [chainIds] : chainIds;\n          const supportedChainIds = await wallet.methods.getSupportedChainIds();\n          if (!cIds.every((cId) => supportedChainIds.includes(cId))) {\n            throw new Error('Unsupported chainId is exist');\n          }\n          await window.leap.enable(chainIds);\n        },\n        getAccount: async (chainId) => {\n          const response = await window.leap.getKey(chainId);\n          return {\n            address: response.bech32Address,\n            name: response.name,\n            public_key: {\n              type: response.algo,\n              value: Buffer.from(response.pubKey).toString('base64'),\n            },\n            is_ledger: response.isNanoLedger,\n          };\n        },\n        signAmino: async (chainId, document, options) => {\n          if (typeof options?.edit_mode?.fee === 'boolean') {\n            window.leap.defaultOptions.sign.preferNoSetFee = options.edit_mode.fee;\n          }\n          if (typeof options?.edit_mode?.memo === 'boolean') {\n            window.leap.defaultOptions.sign.preferNoSetMemo = options.edit_mode.memo;\n          }\n          if (typeof options?.is_check_balance === 'boolean') {\n            window.leap.defaultOptions.sign.disableBalanceCheck = options.is_check_balance;\n          }\n          const signer = options?.signer || (await wallet.methods.getAccount(chainId)).address;\n          const response = await window.leap.signAmino(chainId, signer, document);\n          return {\n            signature: response.signature.signature,\n            signed_doc: response.signed,\n          };\n        },\n        signDirect: async (chainId, document, options) => {\n          if (typeof options?.edit_mode?.fee === 'boolean') {\n            window.leap.defaultOptions.sign.preferNoSetFee = options.edit_mode.fee;\n          }\n          if (typeof options?.edit_mode?.memo === 'boolean') {\n            window.leap.defaultOptions.sign.preferNoSetMemo = options.edit_mode.memo;\n          }\n          if (typeof options?.is_check_balance === 'boolean') {\n            window.leap.defaultOptions.sign.disableBalanceCheck = !options.is_check_balance;\n          }\n          const account = await wallet.methods.getAccount(chainId);\n          if (account.is_ledger) {\n            throw new Error('Ledger is not supported');\n          }\n          const signer = options?.signer || account.address;\n          const signingDoc = {\n            accountNumber: document.account_number,\n            authInfoBytes: document.auth_info_bytes,\n            chainId: document.chain_id,\n            bodyBytes: document.body_bytes,\n          };\n          const response = await window.leap.signDirect(chainId, signer, signingDoc);\n          return {\n            signature: response.signature.signature,\n            signed_doc: {\n              auth_info_bytes: response.signed.authInfoBytes,\n              body_bytes: response.signed.bodyBytes,\n            },\n          };\n        },\n        sendTransaction: async (chainId, tx_bytes, mode) => {\n          const broadcastMode =\n            mode === 1 ? 'block' : mode === 2 ? 'sync' : mode === 3 ? 'async' : 'sync';\n          const txBytes =\n            typeof tx_bytes === 'string'\n              ? new Uint8Array(Buffer.from(tx_bytes, 'base64'))\n              : tx_bytes;\n          const response = await window.leap.sendTx(chainId, txBytes, broadcastMode);\n          const txHash = Buffer.from(response).toString('hex').toUpperCase();\n          return txHash;\n        },\n        addChain: async (chain) => {\n          const coinType = chain.coin_type ? Number(chain.coin_type.replaceAll(\"'\", '')) : 118;\n          await window.leap.experimentalSuggestChain({\n            chainId: chain.chain_id,\n            chainName: chain.chain_name,\n            rpc: chain.lcd_url,\n            rest: chain.lcd_url,\n            bip44: {\n              coinType,\n            },\n            bech32Config: {\n              bech32PrefixAccAddr: chain.address_prefix,\n              bech32PrefixAccPub: chain.address_prefix + 'pub',\n              bech32PrefixValAddr: chain.address_prefix + 'valoper',\n              bech32PrefixValPub: chain.address_prefix + 'valoperpub',\n              bech32PrefixConsAddr: chain.address_prefix + 'valcons',\n              bech32PrefixConsPub: chain.address_prefix + 'valconspub',\n            },\n            currencies: [\n              {\n                coinDenom: chain.display_denom,\n                coinMinimalDenom: chain.base_denom,\n                coinDecimals: chain.decimals || 6,\n                coinGeckoId: chain.coingecko_id || 'unknown',\n              },\n            ],\n            feeCurrencies: [\n              {\n                coinDenom: chain.display_denom,\n                coinMinimalDenom: chain.base_denom,\n                coinDecimals: chain.decimals || 6,\n                coinGeckoId: chain.coingecko_id || 'unknown',\n                gasPriceStep: {\n                  low: chain?.gas_rate?.tiny ? Number(chain?.gas_rate?.tiny) : 0.01,\n                  average: chain?.gas_rate?.low ? Number(chain?.gas_rate?.low) : 0.025,\n                  high: chain?.gas_rate?.average ? Number(chain?.gas_rate?.average) : 0.04,\n                },\n              },\n            ],\n            stakeCurrency: {\n              coinDenom: chain.display_denom,\n              coinMinimalDenom: chain.base_denom,\n              coinDecimals: chain.decimals || 6,\n              coinGeckoId: chain.coingecko_id || 'unknown',\n            },\n          });\n        },\n      },\n    };\n    registerCosmosWallet(wallet);\n  }}\n>\n  Register Leap Wallet\n</button>;"}},"/mintscan/registry/assets":{"title":"How to add your token info","data":{"":"To add asset metadata on mintscan.\n‼️ Please note that tokens of Testnets and unverified networks may not be merged to master.\nFork this repo to your own github account\nClone fork and create new branch\ngit clone git@github.com:YOUR_ACCOUNT/chainlist.git\ncd chainlist\ngit branch <branch_name>\ngit checkout <branch_name>\nAdd the info of your token in the chain that your token needs to be displayed\nCommon info to fill\nField\tDescription\tdenom\tToken's denom.\ttype\tType of the token:\t\t- staking: Native staking token of a chain.\t\t- native: Native token issued on a chain, not the staking token.\t\t- ibc: Token transferred via IBC.\t\t- pool: Token representing a liquidity pool.\t\t- bridge: Token bridged from another network.\t\t- cw20: CW20 token type.\t\t- erc20: ERC20 token type.\torigin_chain\tThe origin chain where this token was issued.\torigin_denom\tOriginal denom of the token.\torigin_type\tOriginal type of the token (staking, native, pool, ibc, bridge, cw20, erc20).\tsymbol\tDisplayed name of the token in the list.\tdecimals\tToken's decimals.\timage\tImage route of the token (optional).\t\tPlace image in ${targetchain}/asset folder. Ensure it's a png file.\tcoinGeckoId\tCoinGecko site's API ID. Leave empty if none.\t\nIf the type is staking, provide the info below\nField\tDescription\tdescription\tA brief summary of the token\t\nIf the type is ibc, provide the info below:\nField\tDescription\tenable\ttrue if IBC transmission is possible (optional).\tchannel\tToken's IBC channel (optional).\tport\tToken's IBC port (optional).\t\tAdd the token's channel and port.\tcounter_party\tCounter party's IBC channel and port (optional).\t\t- channel.\t\t- port.\t\t- denom: Token's denom before IBC transfer.\tpath\tPath of token transfer (optional).\t\tProvide full details if transferred via IBC, bridge, or other path.\tpath\tPath details for bridge tokens (optional).\t\tProvide details if transferred via IBC, bridge, or other path.\tcontract\tContract address for token transfer via contract (optional).\t\nNative Token\n/assets/v2/${chain}/assets.json\n// example OSMOSIS\n[\n  {\n    \"denom\": \"uosmo\",\n    \"type\": \"staking\",\n    \"origin_chain\": \"osmosis\",\n    \"origin_denom\": \"uosmo\",\n    \"origin_type\": \"staking\",\n    \"symbol\": \"OSMO\",\n    \"decimals\": 6,\n    \"description\": \"Osmosis Staking Coin\",\n    \"image\": \"osmosis/asset/osmo.png\",\n    \"coinGeckoId\": \"osmosis\"\n  },\n  {\n    \"denom\": \"uion\",\n    \"type\": \"native\",\n    \"origin_chain\": \"osmosis\",\n    \"origin_denom\": \"uion\",\n    \"origin_type\": \"native\",\n    \"symbol\": \"ION\",\n    \"decimals\": 6,\n    \"description\": \"Native Coin\",\n    \"image\": \"osmosis/asset/ion.png\",\n    \"coinGeckoId\": \"ion\"\n  },\n  // example KUJIRA\n  {\n    \"denom\": \"factory//uusk\",\n    \"type\": \"native\",\n    \"origin_chain\": \"kujira\",\n    \"origin_denom\": \"factory//uusk\",\n    \"origin_type\": \"native\",\n    \"symbol\": \"USK\",\n    \"decimals\": 6,\n    \"description\": \"USK Stable Asset\",\n    \"image\": \"kujira/asset/usk.png\",\n    \"coinGeckoId\": \"usk\"\n  }\n]\nIBC Token\n[\n  // example COSMOS\n  {\n    \"denom\": \"ibc/\",\n    \"type\": \"ibc\",\n    \"origin_chain\": \"osmosis\",\n    \"origin_denom\": \"uosmo\",\n    \"origin_type\": \"staking\",\n    \"symbol\": \"OSMO\",\n    \"decimals\": 6,\n    \"enable\": true,\n    \"path\": \"osmosis>cosmos\",\n    \"channel\": \"channel-141\",\n    \"port\": \"transfer\",\n    \"counter_party\": {\n      \"channel\": \"channel-0\",\n      \"port\": \"transfer\",\n      \"denom\": \"uosmo\"\n    },\n    \"image\": \"osmosis/asset/osmo.png\", // Set image route for base_denom\n    \"coinGeckoId\": \"osmosis\"\n  },\n  // example IRIS\n  {\n    \"denom\": \"ibc/\",\n    \"type\": \"ibc\",\n    \"origin_denom\": \"weth\",\n    \"origin_type\": \"erc20\",\n    \"symbol\": \"WETH\",\n    \"origin_chain\": \"ethereum\",\n    \"decimals\": 18,\n    \"enable\": true,\n    \"path\": \"ethereum>gravity-bridge>iris\",\n    \"channel\": \"channel-29\",\n    \"port\": \"transfer\",\n    \"counter_party\": {\n      \"channel\": \"channel-47\",\n      \"port\": \"transfer\",\n      \"denom\": \"gravity0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"\n    },\n    \"image\": \"ethereum/asset/weth.png\", // Set image route for base_denom\n    \"coinGeckoId\": \"weth\",\n    \"contract\": \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\"\n  }\n]\nBridge Token\n[\n  // example GRAVITY-BRIDGE\n  {\n    \"denom\": \"gravity0x2260fac5e5542a773aa44fbcfedf7c193bc2c599\",\n    \"type\": \"bridge\",\n    \"origin_chain\": \"ethereum\",\n    \"origin_denom\": \"wbtc\",\n    \"origin_type\": \"erc20\",\n    \"symbol\": \"WBTC\",\n    \"decimals\": 8,\n    \"path\": \"ethereum>gravity-bridge\",\n    \"image\": \"ethereum/asset/wbtc.png\",\n    \"coinGeckoId\": \"wrapped-bitcoin\",\n    \"contract\": \"0x2260fac5e5542a773aa44fbcfedf7c193bc2c599\"\n  },\n  // example IRIS\n  {\n    \"denom\": \"htltbcbusd\",\n    \"type\": \"bridge\",\n    \"origin_chain\": \"bnb-beacon-chain\",\n    \"origin_denom\": \"busd\",\n    \"origin_type\": \"bep2\",\n    \"symbol\": \"BUSD\",\n    \"decimals\": 8,\n    \"path\": \"bnb-beacon-chain>iris\",\n    \"image\": \"bnb-beacon-chain/asset/busd.png\",\n    \"coinGeckoId\": \"binance-usd\"\n  }\n]\nPool Token\n// example COSMOS\n[\n  {\n    \"denom\": \"\",\n    \"type\": \"pool\",\n    \"origin_chain\": \"cosmos\",\n    \"origin_denom\": \"\",\n    \"origin_type\": \"pool\",\n    \"symbol\": \"GDEX-1\",\n    \"decimals\": 6,\n    \"description\": \"pool/1\",\n    \"image\": \"cosmos/asset/pool.png\", // Add pool image in the target chain’s folder\n    \"coinGeckoId\": \"\"\n  }\n]\nCommit and push to your fork\ngit add -A\ngit commit -m “Add <YOUR TOKEN NAME>”\ngit push origin <branch_name>\nFrom your repository, make pull request (PR)"}},"/extension/integration/sui/execute-move-call":{"title":"Execute Move Call","data":{"":"Execute Move Call via Cosmostation Extension\nconst payload = {\n  packageObjectId: \"0x2\",\n  module: \"devnet_nft\",\n  function: \"mint\",\n  typeArguments: [],\n  arguments: [\n    \"Cosmostation NFT\",\n    \"An NFT created by Cosmostation Wallet\",\n    \"https://avatars.githubusercontent.com/u/49175386?s=200&v=4\",\n  ],\n  gasBudget: 10000,\n};\nawait window.cosmostation.sui.connect();\nconst response = await window.cosmostation.sui.executeMoveCall(payload);","request#request":"MoveCallTransaction\nexport interface MoveCallTransaction {\n  packageObjectId: ObjectId;\n  module: string;\n  function: string;\n  typeArguments: string[] | TypeTag[];\n  arguments: SuiJsonValue[];\n  gasPayment?: ObjectId;\n  gasBudget: number;\n}","response#Response":"CertifiedTransaction\nTransactionEffects\nexport type SuiTransactionResponse = {\n  certificate: CertifiedTransaction;\n  effects: TransactionEffects;\n};\n{\n  \"certificate\": {\n    \"transactionDigest\": \"QTWZUMmBzPReVUPjxPRPs271Zve7C4rtCRHm8Cisz4x\",\n    \"data\": {\n      \"transactions\": [\n        {\n          \"Call\": {\n            \"package\": {\n              \"objectId\": \"0x0000000000000000000000000000000000000002\",\n              \"version\": 1,\n              \"digest\": \"BN1R9u+4+jOoGiGagW50eT+EE+JxtYLaveBPxHhgsiE=\"\n            },\n            \"module\": \"devnet_nft\",\n            \"function\": \"mint\",\n            \"arguments\": [\n              \"Cosmostation NFT\",\n              \"An NFT created by Cosmostation Wallet\",\n              \"https://avatars.githubusercontent.com/u/49175386?s=200&v=4\"\n            ]\n          }\n        }\n      ],\n      \"sender\": \"0xddee25bee35fa634a1d486d16281f333370ef3f2\",\n      \"gasPayment\": {\n        \"objectId\": \"0x3be2f11263e4c6d77356ba04f053f38ae917bd23\",\n        \"version\": 99,\n        \"digest\": \"aw8yjNgqA/siJay1eJWv/axflLvGwSM+RbXOilKWAlo=\"\n      },\n      \"gasPrice\": 1,\n      \"gasBudget\": 10000\n    },\n    \"txSignature\": \"ALSjaMJTiA34zu/d6nnfBH7SxjQvk988NYcNeW8cHJf0zLvriSbIf3/6q7FDtg/5jCNOBknZ38Hmgg0MAhRs7wdWEU2i63wnssWTOQJmMjz5Wq+PhqtBW+GrkSSWOnRKAA==\",\n    \"authSignInfo\": {\n      \"epoch\": 0,\n      \"signature\": \"qhUPMYuuaMqemq+l5a/rDm7VlFmkzXvxtf1gNdwT1xTuNPGYRE0DYBJ+WNnB/D30\",\n      \"signers_map\": [\n        58, 48, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 16, 0, 0, 0, 0, 0, 2, 0, 3, 0\n      ]\n    }\n  },\n  \"effects\": {\n    \"status\": { \"status\": \"success\" },\n    \"gasUsed\": {\n      \"computationCost\": 464,\n      \"storageCost\": 40,\n      \"storageRebate\": 16\n    },\n    \"transactionDigest\": \"QTWZUMmBzPReVUPjxPRPs271Zve7C4rtCRHm8Cisz4x\",\n    \"created\": [\n      {\n        \"owner\": {\n          \"AddressOwner\": \"0xddee25bee35fa634a1d486d16281f333370ef3f2\"\n        },\n        \"reference\": {\n          \"objectId\": \"0x1eaadc7b76011f5657821a6aa92eae6098689c9a\",\n          \"version\": 100,\n          \"digest\": \"jJ99SfS/MZIqudWmXmdXU8GChiXFsej27kWDz6FCNeQ=\"\n        }\n      }\n    ],\n    \"mutated\": [\n      {\n        \"owner\": {\n          \"AddressOwner\": \"0xddee25bee35fa634a1d486d16281f333370ef3f2\"\n        },\n        \"reference\": {\n          \"objectId\": \"0x3be2f11263e4c6d77356ba04f053f38ae917bd23\",\n          \"version\": 100,\n          \"digest\": \"wgC6a5w4Xqg4D81bOvBiRjkh0m91srqzZP0kLTkCU6Y=\"\n        }\n      }\n    ],\n    \"gasObject\": {\n      \"owner\": { \"AddressOwner\": \"0xddee25bee35fa634a1d486d16281f333370ef3f2\" },\n      \"reference\": {\n        \"objectId\": \"0x3be2f11263e4c6d77356ba04f053f38ae917bd23\",\n        \"version\": 100,\n        \"digest\": \"wgC6a5w4Xqg4D81bOvBiRjkh0m91srqzZP0kLTkCU6Y=\"\n      }\n    },\n    \"events\": [\n      {\n        \"coinBalanceChange\": {\n          \"packageId\": \"0x0000000000000000000000000000000000000002\",\n          \"transactionModule\": \"gas\",\n          \"sender\": \"0xddee25bee35fa634a1d486d16281f333370ef3f2\",\n          \"changeType\": \"Gas\",\n          \"owner\": {\n            \"AddressOwner\": \"0xddee25bee35fa634a1d486d16281f333370ef3f2\"\n          },\n          \"coinType\": \"0x2::sui::SUI\",\n          \"coinObjectId\": \"0x3be2f11263e4c6d77356ba04f053f38ae917bd23\",\n          \"version\": 99,\n          \"amount\": -488\n        }\n      },\n      {\n        \"newObject\": {\n          \"packageId\": \"0x0000000000000000000000000000000000000002\",\n          \"transactionModule\": \"devnet_nft\",\n          \"sender\": \"0xddee25bee35fa634a1d486d16281f333370ef3f2\",\n          \"recipient\": {\n            \"AddressOwner\": \"0xddee25bee35fa634a1d486d16281f333370ef3f2\"\n          },\n          \"objectType\": \"0x2::devnet_nft::DevNetNFT\",\n          \"objectId\": \"0x1eaadc7b76011f5657821a6aa92eae6098689c9a\",\n          \"version\": 100\n        }\n      },\n      {\n        \"moveEvent\": {\n          \"packageId\": \"0x0000000000000000000000000000000000000002\",\n          \"transactionModule\": \"devnet_nft\",\n          \"sender\": \"0xddee25bee35fa634a1d486d16281f333370ef3f2\",\n          \"type\": \"0x2::devnet_nft::MintNFTEvent\",\n          \"fields\": {\n            \"creator\": \"0xddee25bee35fa634a1d486d16281f333370ef3f2\",\n            \"name\": \"Cosmostation NFT\",\n            \"object_id\": \"0x1eaadc7b76011f5657821a6aa92eae6098689c9a\"\n          },\n          \"bcs\": \"Hqrce3YBH1ZXghpqqS6uYJhonJrd7iW+41+mNKHUhtFigfMzNw7z8hBDb3Ntb3N0YXRpb24gTkZU\"\n        }\n      }\n    ],\n    \"dependencies\": [\"CxQQcJfAyDkhxiLiXxrAkFREikMNnngwoGW7kVouMY7w\"]\n  }\n}"}},"/extension/integration/sui/provider":{"title":"Provider","data":{"":"Cosmostation extension support various chains.\nconst sui = () => {\n  if (\"cosmostation\" in window) {\n    return window.cosmostation.sui;\n  } else {\n    window.open(\"https://cosmostation.io/wallet/#extension\");\n    /**\n     * or window.open(\"https://chrome.google.com/webstore/detail/cosmostation/fpkhgmpbidmiogeglndfbkegfdlnajnf\");\n     * */\n  }\n};\nconst provider = sui();"}},"/mintscan/registry/cw20":{"title":"How to add your CW20 token info","data":{"":"To add CW20 asset metadata on mintscan assets.\nJuno Cw20 list supporting\nFork this repo to your own github account\\\nClone fork and create new branch\ngit clone git@github.com:YOUR_ACCOUNT/chainlist.git\ncd chainlist\ngit branch <branch_name>\ngit checkout <branch_name>\nAdd the info of your token in the chain that your token needs to be displayed\nIf there is no chain in the list, create a folder for the chain and add info in the folder\nThen add the name of the folder in: supports.json\nChanges will be updated within 24 hours after merged to master\nkey\tvalue\tchainId\t-1\tchainName\tChain with the token\taddress\tToken's contract_address\tsymbol\tName of token's symbol\tdescription\tA brief summary of the token\tdecimals\tDecimal of the token\timage\tImage route of the token  /${targetChain}/asset add image in the folder Make sure to upload a png file\tdefault\tdefault value is false\tcoinGeckoId\tCoin gecko site's API ID Empty string if none\t\nCw20 Token\n/${targetChain}/contract.json\n// example JUNO\n[\n  {\n    \"chainId\": -1,\n    \"chainName\": \"juno\",\n    \"address\": \"\",\n    \"symbol\": \"DAO\",\n    \"description\": \"DAO DAO\",\n    \"decimals\": 6,\n    \"image\": \"juno/asset/dao.png\",\n    \"default\": false,\n    \"coinGeckoId\": \"\"\n  },\n  {\n    \"chainId\": -1,\n    \"chainName\": \"juno\",\n    \"address\": \"\",\n    \"symbol\": \"NETA\",\n    \"description\": \"NETA\",\n    \"decimals\": 6,\n    \"image\": \"juno/asset/neta.png\",\n    \"default\": true,\n    \"coinGeckoId\": \"neta\"\n  }\n]\nCommit and push to your fork\n  git add -A\n  git commit -m “Add <YOUR TOKEN NAME>”\n  git push origin <branch_name>\nFrom your repository, make pull request (PR)"}},"/mintscan":{"title":"Introduction","data":{"":"Mintscan can easily provide information such as validators and assets publicly through Github","to-provide-information#To provide information":"Folk chainlist repository\nAdd the data\nCreate a pull request\nReview and Merge","registry#Registry":"Validator > Moniker\nAssets > Native\nAssets > CW20\nAssets > ERC20\nEcosystem"}},"/":{"title":"Cosmostation","data":{"":"Cosmostation is a committed interchain service provider in the Cosmos ecosystem, established since its genesis in 2019.\nOur array of tools, including Mintscan, Mintscan API, and Cosmostation wallets showcases our dedication to the community. This developer documentation is your guide to understanding and utilizing our offerings for enhanced protocol development.","mintscan#Mintscan":"Mintscan is the second generation blockchain analytics platform specialized in on-chain data visualization.\nExplorer\nData analyzer\nInterchain Hub","api#API":"First Class Access to Indexed Interchain Data. Streamline your connection to Interchain with Mintscan API.\nRPC Endpoint\nHistorical API\nBuilder API\nStatistics API\nCustom API\nSearch API","extension-wallet#Extension Wallet":"Cosmostation is a non-custodial multi-chain cryptocurrency browser extension wallet that supports 50+ chains including Ethereum, Cosmos, Sui, and more.","mobile-wallet#Mobile Wallet":"Industry leading non-custodial mobile wallet supporting 50+ interchain networks. Enjoy native staking, IBC send, voting, and token swap on mobile."}},"/mintscan/registry/ecosystem":{"title":"How to add your project on Ecosystem (dApp)","data":{"":"To add ecosystem on mintscan.\nYou can add dApp information in the mintscan/dapp/{chain}/constants.json, and upload image file in mintscan/dapp/{chain}/image/{id}.png to display Mintscan's ecosystem page.[mandatory]\nid : Please enter a unique name for dapp in kebab-case format.\nname : Please enter a unique name for dapp.\ndappType : Please select one of the following dapp types. (DAO, Defi, Defi&NFT, NFT, Social, Gamble, Others, Dashboard, Data, Defi&Social, Bridge, Vaults, Lending, System, Dex, Liquid Staking)\ndescription : a description of dapp.\nlink : dapp's link\nimage (file) : Please upload a 1125x600px png file to the path \"mintscan/dapp/{chain}/image/{id}.png\". {id} corresponds to the top id, and it is a unique name for the dapp in kebab-case format.\n[optional]\nsocial.webSite : dapp's official website\nsocial.twitter : dapp's twitter\nsocial.medium : dapp's medium (blog)\nsocial.github : dapp's github\nsocial.docs : dapp's documentation\ncomingSoon : Please enter true if it is a dapp that has not yet been released, otherwise enter false. On the screen, the dapp is displayed as coming soon.\n// example mintscan/dapp/\\{chain\\}/constants.json\n[\n  {\n    \"id\": \"astroport\",\n    \"name\": \"astroport\",\n    \"dappType\": \"Dex\",\n    \"description\": \"Astroport is an AMM(Automated Market Maker)-style decentralized exchange built with CosmWasm smart contracts.\",\n    \"link\": \"https://neutron.astroport.fi/swap\",\n    \"social\": {\n      \"webSite\": \"https://astroport.fi/en\",\n      \"twitter\": \"https://twitter.com/astroport_fi\",\n      \"medium\": \"https://astroport.medium.com/\",\n      \"github\": \"https://github.com/astroport-fi/\",\n      \"docs\": \"https://docs.astroport.fi/\"\n    },\n    \"comingSoon\": false\n  }\n]"}},"/mintscan/registry/endpoint":{"title":"How to add gprc/evm endpoint","data":{"":"To add endpoints managed by chainlist,\nYou must add an endpoint to https://github.com/cosmostation/chainlist/blob/main/chain/{chain}/param.jsonBefore requesting addition, please check whether the endpoint is operating properly using the method below.","check-grpc-endpoint#Check gRPC Endpoint":"GRPC_URL=<GPRC_ENDPOINT_URL>\n#check has grpc endpoints\ngrpcurl $GRPC_URL list\n#check has grpc nodeinfo\ngrpcurl $GRPC_URL cosmos.base.tendermint.v1beta1.Service.GetNodeInfo","check-evm-endpoint#Check EVM Endpoint":"EVM_URL=<EVM_ENDPOINT_URL>\ncurl --location '$EVM_URL' \\\n--header 'Content-Type: application/json' \\\n--data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"eth_getBlockByNumber\",\n    \"params\": [\n        \"latest\",\n        false\n    ],\n    \"id\": 1\n}'"}},"/mintscan/registry/erc20":{"title":"How to add your ERC20 token info","data":{"":"To add erc20 asset metadata on mintscan assets.\nEvmos Erc20 list supporting\nFork this repo to your own github account\nClone fork and create new branch\ngit clone git@github.com:YOUR_ACCOUNT/chainlist.git\ncd chainlist\ngit branch <branch_name>\ngit checkout <branch_name>\nAdd the info of your token in the chain that your token needs to be displayed\nIf there is no chain in the list, create a folder for the chain and add info in the folder\nThen add the name of the folder in: supports.json\nChanges will be updated within 24 hours after merged to master\nkey\tvalue\tchainId\tChainId of the chain\taddress\tToken's contract_address\tchainName\tName of the displayed token\tsymbol\tName of token's symbol\tdecimals\tDecimal of the token\timage\tImage route of the token/${targetChain}/asset add image in the folder Make sure to upload a pngfile\tdefault\tdefault value is false\tcoinGeckoId (optional)\tCoin gecko site's API ID Empty string if none\t\nERC20 Token\n/${targetChain}/contract.json\n[\n  {\n    \"chainId\": 9001,\n    \"chainName\": \"evmos\",\n    \"address\": \"0xD4949664cD82660AaE99bEdc034a0deA8A0bd517\",\n    \"symbol\": \"WEVMOS\",\n    \"description\": \"Wrapped Evmos\",\n    \"decimals\": 18,\n    \"image\": \"evmos/asset/wevmos.png\",\n    \"default\": true,\n    \"coinGeckoId\": \"evmos\"\n  },\n  {\n    \"chainId\": 9001,\n    \"chainName\": \"evmos\",\n    \"address\": \"0xb72A7567847abA28A2819B855D7fE679D4f59846\",\n    \"symbol\": \"ceUSDT\",\n    \"description\": \"Tether USD (Celer)\",\n    \"decimals\": 6,\n    \"image\": \"ethereum/asset/usdt.png\",\n    \"default\": false,\n    \"coinGeckoId\": \"tether\"\n  }\n]\nCommit and push to your fork\ngit add -A\ngit commit -m “Add <YOUR TOKEN NAME>”\ngit push origin <branch_name>\nFrom your repository, make pull request (PR)"}},"/mintscan/registry/moniker":{"title":"How to add your validator moniker image","data":{"":"To add moniker image on mintscan validator tab.\nAdd your image to ${targetchain}/moniker folder\nImage with png format and validator address name\nExample will display cosmostation validator moniker logo for cosmos"}},"/mintstation/cli/command":{"title":"Useful CLI Commands","data":{"":"Get standard debug info from the mint daemon:\nmintstationd status\nCheck if your node is catching up:\n# Query via the RPC (default port: 26657)\ncurl http://localhost:26657/status | jq .result.sync_info.catching_up\nGet your node ID:\nmintstationd tendermint show-node-id\nCheck if you are jailed or tombstoned:\nmintstationd query slashing signing-info $(mintstationd tendermint show-validator)\nSet the default chain for commands to use:\nmintstationd config chain-id mintstation-1\nGet your valoper address:\nmintstationd keys show <your-key-name> -a --bech val\nSee keys on the current box:\nmintstationd keys list\nImport a key from a mnemonic:\nmintstationd keys add <new-key-name> --recover\nExport a private key (warning: don't do this unless you know what you're doing!)\nmintstationd keys export <your-key-name> --unsafe --unarmored-hex\nWithdraw rewards (including validator commission), where mintvaloper1... is the validator address:\nmintstationd tx distribution withdraw-rewards <mintvaloper1...> --from <your-key>  --commission\nStake:\nmintstationd tx staking delegate <mintvaloper1...> <AMOUNT>umint --from <your-key>\nFind out what the JSON for a command would be using --generate-only:\nmintstationd tx bank send $(mintstationd keys show <your-key-name> -a) <recipient addr> <AMOUNT>umint --generate-only\nQuery the results of a gov vote that has ended, from a remote RPC (NB - you have to specify a height before the vote ended):\n mintstationd q gov votes 1 --height <height-before-vote-ended> --node https://rpc-archive.mintnetwork.io:443\nTransfer mint to another chain (osmosis) with IBC\nmintstationd tx ibc-transfer transfer transfer channel-0 <osmo1...> 1000000umint --from <mint1...> --node https://rpc-archive.mintnetwork.io:443  --packet-timeout-height 0-0\nQuery the validator set (and jailed status) via CLI:\nmintstationd query staking validators --limit 1000 -o json | jq -r '.validators[] | [.operator_address, (.tokens|tonumber / pow(10; 6)), .description.moniker, .jail, .status] | @csv' | column -t -s\",\" | sort -k2 -n -r | nl\nGet contract state:\nmintstationd q wasm contract-state all <contract-address>"}},"/mintstation/cli/setup":{"title":"Setup CLI","data":{"build#Build":"Build Requirements\nGo 1.20.+\nClone source from repository:\ngit clone https://github.com/cosmostation/mintstation\ncd mintstation\ngit checkout {SET_CURRENT_VERSION}\nOnce you're on the correct tag, you can build:\n# from mintstation dir\nmake install\nTo confirm that the installation has succeeded, you can run:\nmintstationd version\n#v0.0.1","configure#Configure":"Set the chain-id & node,\n#Update config.toml\nmintstationd config chain-id mintstation-1\nmintstationd config node {NODE_RPC_ENDPOINT:PORT}"}},"/mintstation/contracts/compile":{"title":"Compile Contracts","data":{"":"This guide is from the official CosmWasm/rust-optimizer repository. This method of compiling the contract will optimize the final build so that it reduces gas consumption.Example contracts for this can be found at https://github.com/CosmWasm/cw-examples. This repository requires this section to compile since multiple contracts are involved in a single repository.","single-contract-repository#Single Contract Repository":"The easiest way is to simply use the published docker image. You must run this in the root of the smart contract repository you wish to compile. It will produce an artifacts directory with <crate_name>.wasm and contracts.txt containing the hashes. This is just one file.\ndocker run --rm -v \"$(pwd)\":/code \\\n  --mount type=volume,source=\"$(basename \"$(pwd)\")_cache\",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/rust-optimizer:0.12.11\n# If you you use an ARM machine (Ex: Mac M1), you need to use the following\n# This is experimental and should not be used for production use\ndocker run --rm -v \"$(pwd)\":/code \\\n  --mount type=volume,source=\"$(basename \"$(pwd)\")_cache\",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/rust-optimizer-arm64:0.12.11\nBy running this in the root of your project, it will compile your contract into an artifacts/ folder. From here you can upload it to chain, collect the store code, and interact with it as you design","multiple-contract-repository-mono-repo#Multiple Contract Repository (Mono Repo)":"Sometime you want many contracts to be related and import common functionality. This is exactly the case of cosmwasm-plus. In such a case, we can often not just compile from root, as the compile order is not deterministic and there are feature flags shared among the repos. This has lead to issues in the past.For this use-case there is second docker image, which will compile all the contracts/* folders inside the workspace and do so one-by-one in alphabetical order. It will then add all the generated wasm files to an artifacts directory with a checksum, just like the basic docker image (same output format).To compile all contracts in the workspace deterministically, you can run:\ndocker run --rm -v \"$(pwd)\":/code \\\n  --mount type=volume,source=\"$(basename \"$(pwd)\")_cache\",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/workspace-optimizer:0.12.11\n# If you you use an ARM machine (Ex: Mac M1), you need to use the following\n# This is experimental and should not be used for production use\ndocker run --rm -v \"$(pwd)\":/code \\\n  --mount type=volume,source=\"$(basename \"$(pwd)\")_cache\",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/workspace-optimizer-arm64:0.12.11\nNOTE: See the difference with workspace-optimizer vs rust-optimizer in the previous single contract example.\\"}},"/mintstation/cli":{"title":"CLI Introduction","data":{"introduction#Introduction":"mintstationd is a command line client for the Mintstation. Mintstation users can use mintstationd to send transactions to the Mintstation network and query the blockchain data.See here for instructions on installing mintstationd.","working-directory-a-hrefworking-directory-idworking-directorya#Working Directory ":"The default working directory for the mintstationd is $HOME/.mintstation, which is mainly used to store configuration files and blockchain data. The Mintstation key data is saved in the working directory of mintstationd. You can also specify the mintstationd working directory by using the --home flag when executing mintstationd.","connecting-to-a-full-node#Connecting to a Full-Node":"By default, mintstationd uses tcp://localhost:26657 as the RPC address to connect to the Mintstation network. This default configuration assumes that the machine executing mintstationd is running as a full-node.The RPC address can be specified to connect to any full-node with an exposed RPC port by adding the --node flag when executing mintstationd"}},"/mintstation/contracts/create":{"title":"Create Contracts","data":{"":"To implement a wasm smart contract, it is highly recommended to learn Rust first. Rust is the language commonly used for wasm development and is well-regarded for its stability and performance. You can begin your Rust learning journey by referring to the following link:Rust Language Learning GuideFor smart contract development, you can follow the structure provided by CosmWasm's template. This template will help you understand the project's architecture and enable you to develop your contract more systematically. You can find the template at the following link:CosmWasm Template, book.cosmwasm.comAmong the popular smart contract samples, there are cw20 and cw721 implementations. cw20 represents a widely-used token contract, while cw721 implements a Non-Fungible Token (NFT) contract. These samples can be valuable references during your development process. You can explore the code for each sample through the links below:cw20, cw721For all great CosmWasm tools, https://github.com/CosmWasm/awesome-cosmwasmAlthough smart contract development can be complex, leveraging the provided resources will increase your chances of successfully completing your project. Additionally, make sure to actively engage with the community and online resources to continue your learning journey and receive ongoing support. Best of luck!"}},"/mintstation/contracts/deploy":{"title":"Deploy Contracts","data":{"prerequisite#PreRequisite":"Make sure you follow the create a contract guide first for your project. Once you have a contract compiled in the artifacts/*.wasm directory, you are ready for this guide.","upload#Upload":"You need to upload the contract via the CLI to chain. To do this, perform the following\nTXFLAGS=\"--chain-id=mintstation-1 --gas-prices=0.025umint --gas=auto --gas-adjustment 1.3\"\nmintstationd tx wasm store artifacts/CONRTACT_NAME.wasm \\\n    --from <KEY> $TXFLAGS -y --broadcast-mode=block\nThis will then return a transaction hash. With this data, you need to query it to get the code id of the contract on chain\nmintstationd q tx  --output=json\nThis will return the data about the transaction, and give us the code id of our contract\n{\n  \"height\": \"294601\",\n  \"txhash\": \"\",\n  \"codespace\": \"\",\n  \"code\": 0,\n  \"data\": \"\",\n  \"raw_log\": \"[{\\\"events\\\":[{\\\"type\\\":\\\"message\\\",\\\"attributes\\\":[{\\\"key\\\":\\\"action\\\",\\\"value\\\":\\\"/cosmwasm.wasm.v1.MsgStoreCode\\\"},{\\\"key\\\":\\\"module\\\",\\\"value\\\":\\\"wasm\\\"},{\\\"key\\\":\\\"sender\\\",\\\"value\\\":\\\"mint1hj5fveer5cjtn4wd6wstzugjfdxzl0xps73ftl\\\"}]},{\\\"type\\\":\\\"store_code\\\",\\\"attributes\\\":[{\\\"key\\\":\\\"code_checksum\\\",\\\"value\\\":\\\"\\\"},{\\\"key\\\":\\\"code_id\\\",\\\"value\\\":\\\"13\\\"}]}]}]\",\n  \"logs\": [\n    {\n      \"msg_index\": 0,\n      \"log\": \"\",\n      \"events\": [\n        {\n          \"type\": \"message\",\n          \"attributes\": [\n            {\n              \"key\": \"action\",\n              \"value\": \"/cosmwasm.wasm.v1.MsgStoreCode\"\n            },\n            {\n              \"key\": \"module\",\n              \"value\": \"wasm\"\n            },\n            {\n              \"key\": \"sender\",\n              \"value\": \"mint1hj5fveer5cjtn4wd6wstzugjfdxzl0xps73ftl\"\n            }\n          ]\n        },\n        {\n          \"type\": \"store_code\",\n          \"attributes\": [\n            {\n              \"key\": \"code_checksum\",\n              \"value\": \"\"\n            },\n            {\n              \"key\": \"code_id\",\n              \"value\": \"13\"\n            }\n          ]\n        }\n      ]\n    }\n  }]\n}\nWe can see both raw_log and also logs[0].events[1].store_code shows the code_id being 13. If you wish the automate this return code in bash to a variable, you can \n# ensure jq is installed\nUPLOAD_TX_HASH=\nCODE_ID=$(mintstationd q tx $UPLOAD_TX_HASH --output json | jq -r '.logs[0].events[] | select(.type == \"store_code\").attributes[] | select(.key == \"code_id\").value') && echo \"Code Id: $CODE_ID\"","instantiate#Instantiate":"With the code now being up on chain, we can now run logic to setup our own copy of the contract which we control. This will then give us a unique contract address for others to interact with in accordance with the contract logic. This example is from the cosmwasm/cw-template.Ensure you change CODE_ID to match your code id from the store code\nFLAGS=\"--chain-id=mintstation-1 --gas-prices=0.025umint --gas=auto --gas-adjustment 1.3\"\n#Example1\nCODE_ID=1\nmintstationd tx wasm instantiate \"$CODE_ID\" '{\"count\":0}' --label \"contract\" $FLAGS -y --admin <your-address-here>\n#cw20\nCODE_ID=2\nINIT='{\"name\":\"CW20\",\"symbol\":\"TOKEN\",\"decimals\":2,\"initial_balances\":[{\"amount\":\"1000000\",\"address\":<address>}]}'\nmintstationd tx wasm instantiate \"$CODE_ID\" \"$INIT\" --from <account> --label \"cw-token\"  $FLAGS -y --admin <your-address-here>"}},"/mintstation/contracts/execute":{"title":"Execute Contracts","data":{"command-line-interface#Command Line Interface":"When you execute a message, a user can also pass through a flag which sends funds from their account to the contract to do logic. You can check if a user sends any funds in your contract's execute endpoint with the info.funds array of Coins sent by the user. These funds then get added to the contracts balance just like any other account. So it is up to you as the developer to ensure to save how many funds each user has sent via a BTreeMap or other object storage in state (if they can redeem funds back at a later time).To send funds to a contract with some arbitrary endpoint, you use the --amount flag.\nmintstationd tx wasm execute CONTRACT '{\"some_endpoint\":{}}' --amount 1000000umint\nIf the \"some_endpoint\" execute errors on the contract, the funds will remain in the users account.","typescript#Typescript":"import type { Coin } from '@cosmjs/stargate';\nimport { SigningStargateClient, StargateClient, type StdFee } from '@cosmjs/stargate';\nimport type { OfflineAminoSigner } from '@cosmjs/amino';\nimport type { OfflineDirectSigner } from '@cosmjs/proto-signing';\nimport { SigningCosmWasmClient } from '@cosmjs/cosmwasm-stargate';\nlet RPC = '<RPC_ENDPOINT>';\nconst get_wallet_for_chain = async (\n  chain_id: string,\n): Promise<OfflineAminoSigner | OfflineDirectSigner> => {\n  // open keplr\n  const cosmostation = window as CosmostationWindow;\n  if (keplr === undefined) {\n    throw new Error('Cosmostation not found');\n  }\n  let signer = cosmostation.getOfflineSignerAuto;\n  if (signer === undefined) {\n    throw new Error('Cosmostation not found');\n  }\n  return signer(chain_id);\n};\nlet wallet = await get_wallet_for_chain('mintstation-1');\nlet address = (await wallet.getAccounts())[0].address;\nlet from_client = await SigningCosmWasmClient.connectWithSigner(RPC, wallet, {\n  prefix: 'mint',\n});\nconst msg = { some_endpoint: {} };\nlet fee: StdFee = {\n  amount: [{ amount: '5000', denom: 'umint' }],\n  gas: '500000',\n};\nlet send_amount: Coin = {\n  amount: '100000',\n  denom: 'umint',\n};\nawait from_client\n  .execute(address, REVIEWS_CONTRACT_ADDRESS, msg, fee, 'memo', send_amount)\n  .then((res) => {\n    console.log(`Success @ height ${res.height}\\n\\nTxHash: ${res.transactionHash}`);\n  });"}},"/mintstation/contracts/query":{"title":"Query Contracts","data":{"command-line-interface#Command Line Interface":"The most common way to query a cosmwasm smart contract is within the mintstationd wasm smart query command. This follows the following format where query is a JSON string with no spaces. By default, the least amount of data this can be is an empty JSON payload '{}'.\nmintstationd query wasm contract-state smart [contract_bech32] [query] [flags]\nFor this example, we are going to use a random NFT contract on the mint chain. This will show you how to brute force query a contract if you have no idea what the query schema of the contract is. At this time, there is no way to query the format of a contract's requests, but this is something many are actively working on.Now we attempt to query this contract address and extract some data from it and get which queries are allowed. As you can see, we pass through a random payload for abcde so that the contract will return actual valid query requestsNOTE: A Query can never be empty such as '{}' given you need to specify the path of data you want to reach.{% hint style=\"info\" %}\nThe query shows CW721 Base is this contracts name. As this is a standard contract, all messages can be found in the CosmWasm/cw-nfts repository on github\nhttps://github.com/CosmWasm/cw-nfts/blob/main/contracts/cw721-base/src/msg.rs\n{% endhint %}From this, we now know all of the query endpoints and can requests something more specific from the contract for our usage. Let's get\nCONTRACT=\nmintstationd q wasm contract-state smart $CONTRACT '{\"all_tokens\":{}}'\ndata:\n  tokens:\n  - \"0\"\n  - \"1\"\n  - \"2\"\n  - \"3\"\n  - \"4\"\n  - \"5\"\n  - \"6\"\n  - \"7\"\n  - \"8\"\n# You can use --output=json to read it via JSON form\n# mintstationd q wasm contract-state smart $CONTRACT '{\"all_tokens\":{}}' --output=json | jq .data\nHere we can see there are 8 tokens in this set. Lets query one of the NFTs information\nCONTRACT=\nmintstationd q wasm contract-state smart $CONTRACT '{\"nft_info\":{}}'\n# missing field `token_id`: query wasm contract failed\nJust like the first query, we can see that the payload needs more information. It returned an error that we need to specify the token_id we want the nft_info for. Note, Uint128 sized numbers are read as a string\nCONTRACT=\nmintstationd q wasm contract-state smart $CONTRACT '{\"nft_info\":{\"token_id\":\"8\"}}'\n# data:\n#   extension: null\n#   token_uri: ipfs:///metadata.json","rest-api-query#Rest API Query":"If you wish to query the data more programmatically with an application such as Python, you may be better suited to use the rest API. You can find these endpoints on https://cosmos.directory/mint/nodes in the REST section.This query endpoint can be found via Mintstation's SwaggerUI. However, some modules you will not be able to easily find the endpoint. To do this, you will need to search through the proto files. Here we know we want to query the cosmwasm module, which is called wasmd on chain. This repo is found at https://github.com/cosmwasm/wasmd.\nIn this module, you can see the proto folder in the root of the repo. This will house the endpoints the module exposes so we can find the above path which. This is a query so we find the query proto file\nhttps://github.com/CosmWasm/wasmd/blob/main/proto/cosmwasm/wasm/v1/query.proto\\\noption go_package = \"github.com/CosmWasm/wasmd/x/wasm/types\";\noption (gogoproto.goproto_getters_all) = false;\noption (gogoproto.equal_all) = false;\n// Query provides defines the gRPC querier service\nservice Query {\n   ...\n  // SmartContractState get smart query result from the contract\n  rpc SmartContractState(QuerySmartContractStateRequest)\n      returns (QuerySmartContractStateResponse) {\n    option (google.api.http).get =\n        \"/cosmwasm/wasm/v1/contract/{address}/smart/{query_data}\";\n  }\n  ...\n{% hint style=\"info\" %}\nYou must base64 encode the JSON payload for REST API Request. Just take your JSON payload and\n- put it into https://www.base64encode.org/\n- or use Mac / Linux built in command\necho '{\"all_tokens\":{}}' | base64\n# eyJhbGxfdG9rZW5zIjp7fX0K\n{% endhint %}With this, we can now query the contract and gather the data. You can use your web browser, or a library like httpx / requests in Python for automated bots. Be aware that many API providers will late limit the number of requests you can make.\nhttps://api.mint.strange.love/cosmwasm/wasm/v1/contract//smart/eyJhbGxfdG9rZW5zIjp7fX0K\n{\n  \"data\": {\n    \"tokens\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"]\n  }\n}","cosmology-smart-contract-query#Cosmology Smart Contract Query":"Using CosmWasm/ts-codegen, you can create an NPM module to make interactions and queries into dev-friendly Typescript classes to allow you to focus on shipping code.Here are a few tutorials from cosmology:\nts-codegen overview for CosmWasm\nCosmWasm Contract to Typescript npm module\nConfigure CosmWasm ts-codegen in your Contracts repo\nQuery a CosmWasm smart contract from ts-codegen\nEnable React Query\nEnable Recoil\nIntegrate Telescope with ts-codegen"}},"/mintstation":{"title":"Introduction","data":{"":"Mintstation is a network designed for testing the Cosmos SDK. It provides access to the latest features of the Cosmos ecosystem, allowing users to leverage CosmWasm smart contracts.In this documentation, the following topics are covered:\nLocal network installation\nCLI usage\nRunning a full node and participating as a validator\nUtilizing Cosmwasm for smart contract development\nCustom module development\nMintstation offers a testing ground for developers and users to explore and experiment with the capabilities of the Cosmos SDK while having the ability to interact with CosmWasm smart contracts. The documentation provides comprehensive guidance on setting up a local network, utilizing the CLI, engaging as a validator, and leveraging Cosmwasm for smart contract deployment. Additionally, developers are encouraged to explore custom module development to tailor the network to their specific needs.By providing an environment that maintains the latest features of the Cosmos SDK and supports Cosmwasm smart contracts, Mintstation facilitates a dynamic and insightful experience for individuals and teams working within the Cosmos ecosystem."}},"/mintstation/validator/command":{"title":"Useful commands","data":{"upgrade-to-a-validator#Upgrade to a validator":"Do not attempt to upgrade your node to a validator until the node is fully in sync as per the previous step.To upgrade the node to a validator, you will need to submit a create-validator transaction:\nmintstationd tx staking create-validator \\\n  --amount 1000000umint \\\n  --commission-max-change-rate \"0.1\" \\\n  --commission-max-rate \"0.20\" \\\n  --commission-rate \"0.1\" \\\n  --min-self-delegation \"1\" \\\n  --details \"validators write bios too\" \\\n  --pubkey=$(mintstationd tendermint show-validator) \\\n  --moniker \"$MONIKER_NAME\" \\\n  --chain-id $CHAIN_ID \\\n  --gas-prices 0.025umint \\\n  --from <key-name>\nThe above transaction is just an example. There are many more flags that can be set to customise your validator, such as your validator website, or keybase.io id, etc. To see a full list:\nmintstationd tx staking create-validator --help\nUnjail\nmintstationd tx slashing unjail --from <key-name> --chain-id mintstation-1 --fees 100umint\nTo track your validator's signing history, copy the validator public key:\nmintstationd tendermint show-validator\nUse your validators public key queried above as the validator-pubkey below:\nmintstationd query slashing signing-info <validator-pubkey>\nExample:\nmintstationd query slashing signing-info '{\"@type\":\"/cosmos.crypto.ed25519.PubKey\",\"key\":\"HlixoxNZBPq4pBOYEimtSq9Ak4peBISVsIbI5ZHrEAU=\"}'"}},"/mintstation/playground":{"title":"Playground","data":{"":"Welcome to Mintstation Playground, it makes easy to connect your wallet to the Mintstation blockchain and build your projects seamlessly.With this project, you can easily connect your wallet in any environment, be it on a PC or mobile device. Using the Mintscan API, you can conveniently build your products with ease.\nMintscan API\nCosmostation Docs\nMintstation provides an environment where you can test and utilize the cosmos-sdk and smart contracts. You can test various features and see the results immediately without the need for setting up a separate network.\nMintstation Mintscan\nMintstation Github","how-to-use#How to use":"Take a look at the code in Mintstation Playground to experience the easiest way to understand the Cosmos SDK and develop a DApp. This is the simplest way to grasp the Cosmos ecosystem.\nGithub : https://github.com/comostation/mintstation-playground\nDemo : https://play-mintstation.web.app/","support-features#Support features":"","dashboard#Dashboard":"Using the Mintscan API, you can easily get history or create a dashboard where you can view asset information at a glance.","faucet#Faucet":"Easily access the Faucet feature to obtain Mintstation tokens for testing and development purposes.","bank-module#Bank Module":"You can easily implement a function that allows you to easily send tokens within Mintstation.","validator-list#Validator List":"Get information about validators within Mintstation.","staking-module#Staking Module":"You can easily implement the function to easily stake and unstake tokens within Mintstation.","tbd--governance-smart-contracts-swap#TBD : Governance, Smart Contracts, Swap":""}},"/mintstation/validator/delegations":{"title":"Delegations","data":{"":"If you wish to perform more extensive testing and require additional delegations, please don't hesitate to get in touch with us at mintstation@cosmostation.io.We are more than happy to provide you with the necessary delegations to support your testing efforts. Our delegation services aim to help you thoroughly evaluate and explore the features and capabilities of our platform.By reaching out to us, you can access a wide range of resources and support to make the most out of your testing experience. Whether you are testing staking, governance, or any other aspects of our system, we want to ensure that you have a beautiful and seamless experience.Feel free to contact us with any specific requirements or questions you may have. Our team at mintstation@cosmostation.io is ready to assist you, and we look forward to supporting your testing journey!"}},"/mintstation/validator/localnet":{"title":"Localnet","data":{"setup-local-network#Setup Local Network":"To set up a single local network easily, you can directly run the script below, and it will start working immediately:To get up and running with the mintstationd binary, please follow the instructions here.\nAPP_HOME=\"$HOME/.mintstation\"\nRPC=\"http://localhost:26657\"\nCHAIN_ID=\"localnet-1\"\nMONIKER=\"Moniker\"\nmintstationd init ${MONIKER} --chain-id ${CHAIN_ID} --home ${APP_HOME}\nsed -i -r 's/minimum-gas-prices = \"0stake\"/minimum-gas-prices = \"0.0001umint\"/' ${APP_HOME}/config/app.toml\nsed -i -e 's/\\\"stake\\\"/\\\"umint\\\"/g' ${APP_HOME}/config/genesis.json\nmintstationd keys add validator --keyring-backend test\nMY_VALIDATOR_ADDRESS=$(mintstationd keys show validator --keyring-backend test -a)\nmintstationd add-genesis-account $MY_VALIDATOR_ADDRESS 10000000000umint\nmintstationd gentx validator 10000000umint --chain-id localnet-1 --keyring-backend test\nmintstationd collect-gentxs\nmintstationd start --home ${APP_HOME}"}},"/mintstation/validator/upgrade":{"title":"Node Upgrades","data":{"upgrades#Upgrades":"Release procedures for validators and node operators are explained here.","upgrade-types#Upgrade types":"There are two types of upgrades that happen on Mintstation Network. They are:\nPlanned feature upgrades or planned patches\nUnplanned security upgrades.","planned-upgrade-via-governance#Planned upgrade (via governance)":"Planned upgrades, as the name suggests, are upgrades that are developed and proposed via governance. If approved by the community, these upgrades are undertaken by the chain automatically halting at the planned upgrade height.Node operators are then required to swap the binary for the planned upgrade binary. After all node operators have upgraded and started their nodes the network will continue in the upgraded state.","unplanned-upgrade#Unplanned upgrade":"Where emergency security patches are required node operators will be required to halt their nodes manually at the required upgrade height, swap the patched binary and restart their nodes. After all node operators have upgraded and started their nodes the network will continue in the upgraded state."}},"/mobile/article":{"title":"Articles","data":{"":"How to Derive(Add) & Manage WalletsWallet Management“dApp” on Cosmostation Mobile WalletIntroducing AuthZ on Cosmostation MobileGas OptimizationKava DeFiOsmosis and Sifchain DEXNFT on Cosmostation MobileStarname Service"}},"/mobile":{"title":"Introduction","data":{"":"Mobile wallets support various types of services.\nAccess dApps on desktop/mobile via QR code scanning.\nConnect with dApps from your mobile browser via Deep Link.\nIn-app browser support on mobile wallets.\nCosmostation Mobile Wallet supports dApps through various methods.\nCosmostation(Same way as Extension)\nCosmos-Kit\nWalletConnect 1.0(Deprecated), WalletConnect 2.0\nConnections using Cosmostation and WalletConnect also implement the Keplr and Web3j specifications."}},"/mintstation/validator/mainnet":{"title":"Joining Mainnet","data":{"":"To get up and running with the mintstationd binary, please follow the instructions here.","setting-up-the-node#Setting up the Node":"These instructions will direct you on how to initialize your node, synchronize to the network and upgrade your node to a validator.","initialize-the-chain#Initialize the chain":"CHAIN_ID=mintstation-1\nMONIKER_NAME=<moniker-name>\nmintstationd init \"$MONIKER_NAME\" --chain-id $CHAIN_ID\nThis will generate the following files in ~/.mintstation/config/\ngenesis.json\nnode_key.json\npriv_validator_key.json","download-the-genesis-file#Download the genesis file":"Download the the geneis file.\n# Download genesis.json file (https://github.com/cosmostation/mintstation)\nrm ~/.mintstation/config/genesis.json\ncurl -sS \"https://rpc-mintstation.cosmostation.io/genesis\" | jq .result.genesis > $HOME/.mintstation/config/genesis.json\nThis will replace the genesis file created using mintstationd init command with the mainnet genesis.json.","set-seeds#Set seeds":"We can set the seeds by retrieving the list of seeds from the mintstation repo and using sed to inject into ~/.mintstation/config/config.toml:\n# Set the base repo URL for mainnet & retrieve seeds\nCHAIN_ID=mintstation-1\nCHAIN_REPO=\"https://raw.githubusercontent.com/cosmostation/mintstation/main/$CHAIN_ID\" && \\\nexport SEEDS=\"$(curl -sL \"$CHAIN_REPO/seeds.txt\")\"\n# Add seeds to config.toml\nsed -i.bak -e \"s/^seeds *=.*/seeds = \\\"$SEEDS\\\"/\" ~/.mintstation/config/config.toml","set-minimum-gas-prices#Set minimum gas prices":"For RPC nodes and Validator nodes we recommend setting the following minimum-gas-prices. As we are a permissionless wasm chain, this setting will help protect against contract spam and potential wasm contract attack vectors.In $HOME/.mintstation/config/app.toml, set minimum gas prices:\nsed -i.bak -e \"s/^minimum-gas-prices *=.*/minimum-gas-prices = \\\"0.0025umint\\\"/\" ~/.mintstation/config/app.toml","create-or-restore-a-local-key-pair#Create (or restore) a local key pair":"Either create a new key pair, or restore an existing wallet for your validator:\nmintstationd keys add <key-name>\n# OR\n# Restore existing mint wallet with mnemonic seed phrase.\n# You will be prompted to enter mnemonic seed.\nmintstationd keys add <key-name> --recover\n# Query the keystore for your public address\nmintstationd keys show <key-name> --bech val -a\nReplace <key-name> with a key name of your choosing.After creating a new key, the key information and seed phrase will be shown. It is essential to write this seed phrase down and keep it in a safe place. The seed phrase is the only way to restore your keys.","get-some-tokens#Get some tokens":"We are serving only a few tokens for you to test or do something what you want.\n# Check your address which you've generated & copy the address\nmintstationd keys show <key-name> -a\n# Go to minstation faucet and paste your address on it\nhttps://faucet-mintstation.cosmostation.io\nIf you want to get more tokens or delegations, Please contact us from here.","syncing-the-node#Syncing the node":"There are methods to sync a node to the network:","sync-from-genesis#Sync from genesis":"After starting the mintstationd daemon, the chain will begin to sync to the network. The time to sync to the network will vary depending on your setup and the current size of the blockchain, but could take a very long time. To query the status of your node:\n# Start for your node to sync from genesis\nmintstationd start\n# Query via the RPC (default port: 26657)\ncurl http://localhost:26657/status | jq .result.sync_info.catching_up\nIf this command returns true then your node is still catching up. If it returns false then your node has caught up to the network current block and you are safe to proceed to upgrade to a validator node.When syncing from genesis, you will need to perform upgrades while catching up to the head. mintstation-1 upgrades are detailed in node-upgrade.md along with a description of each type of upgrade.","sync-with-statesync#Sync with statesync":"When a cosmos-sdk based chain already started to make a new consensus, you need some time to sync from genesis with your node.So, you can resolve this problem by using statesync functionality, which is general characteristic in cosoms-sdk based chain. And then we recommend to sync with statesync by using our snapshot provider rpc endpoint.\n# Setup statesync in your config.toml\nSNAP_RPC=\"https://rpc-mintstation.cosmostation.io:443\"\nLATEST_HEIGHT=$(curl -s $SNAP_RPC/block | jq -r .result.block.header.height); \\\nBLOCK_HEIGHT=$((LATEST_HEIGHT - 1500)); \\\nTRUST_HASH=$(curl -s \"$SNAP_RPC/block?height=$BLOCK_HEIGHT\" | jq -r .result.block_id.hash)\nsed -i.bak -E \"s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1true| ; \\\ns|^(rpc_servers[[:space:]]+=[[:space:]]+).*$|\\1\\\"$SNAP_RPC,$SNAP_RPC\\\"| ; \\\ns|^(trust_height[[:space:]]+=[[:space:]]+).*$|\\1$BLOCK_HEIGHT| ; \\\ns|^(trust_hash[[:space:]]+=[[:space:]]+).*$|\\1\\\"$TRUST_HASH\\\"|\" $HOME/.mintstation/config/config.toml\n# Check diff between before and after\ndiff $HOME/.mintstation/config/config.toml $HOME/.mintstation/config/config.toml.bak\n# Start for your node to sync with statesync\nmintstationd start","backup-critical-files#Backup critical files":"There are certain files that you need to backup to be able to restore your validator if, for some reason, it damaged or lost in some way. Please make a secure backup of the following files located in ~/.mintstation/config/:\npriv_validator_key.json\nnode_key.json\nIt is recommended that you encrypt the backup of these files."}},"/mobile/integration/cosmjs":{"title":"Integrate cosmjs","data":{"":"Cosmjs TutorialCosmjs Example CodeCosmjs Example Page","add-package#Add package":"yarn add @cosmostation/cosmos-client\nnpm install @cosmostation/cosmos-client","offline-signer#Offline Signer":"import { getOfflineSigner } from \"@cosmostation/cosmos-client\";\nconst offlineSigner = await getOfflineSigner(CHAIN_ID);\nimport { getOfflineSigner } from \"@cosmostation/cosmos-client\";\nimport { GasPrice, calculateFee } from \"@cosmjs/stargate\";\nimport { SigningCosmWasmClient } from \"@cosmjs/cosmwasm-stargate\";\nconst offlineSigner = await getOfflineSigner(CHAIN_ID);\nconst rpcEndpoint = RPC_END_POINT;\nconst client = await SigningCosmWasmClient.connectWithSigner(\n  rpcEndpoint,\n  offlineSigner\n);\n//getAccounts\nconst accounts = await offlineSigner.getAccounts();\n//execute\nconst gasPrice = GasPrice.fromString(\"0.01denom\");\nconst fees = {\n  upload: calculateFee(1500000, gasPrice),\n  init: calculateFee(500000, gasPrice),\n  exec: calculateFee(500000, gasPrice),\n};\nconst result = await client.execute(\n  accounts[0].address,\n  RECEIPT_ADDRESS,\n  MESSAGE,\n  fees.exec\n);"}},"/mobile/integration/walletconnect/accounts":{"title":"Accounts","data":{"":"Use account on Cosmostation Mobile Wallet via WalletConnect.","get-accounts#Get Accounts":"Select an account after checking unsupported chains or empty accounts.The response only contains selected account.\nexport function getAccountRequest(chainIds) {\n  return {\n    id: payloadId(),\n    jsonrpc: \"2.0\",\n    method: \"cosmostation_wc_accounts_v1\",\n    params: chainIds,\n  };\n}\nconst request = getAccountRequest([CHAIN_ID, NOT_SUPPORTED_CHAIN_ID]);\nconnector\n  .sendCustomRequest(request)\n  .then((accounts) => {\n    setAccounts(accounts);\n    console.log(accounts.length == 1);\n  })\n  .catch((error) => {\n    console.error(error);\n  });\ntype AccountResponse = {\n  name: string;\n  algo: string;\n  address: Uint8Array;\n  pubKey: string;\n  bech32Address: string;\n};"}},"/mobile/integration/walletconnect/connect":{"title":"Connect","data":{"":"Cosmostation Mobile Wallet supports dApps via WalletConnect.(Deprecated)WalletConnect Example CodeWalletConnect Example Page\nimport WalletConnect from \"@walletconnect/client\";\nexport async function connect() {\n  const connector = new WalletConnect({\n    bridge: \"https://bridge.walletconnect.org\",\n    signingMethods: [\n      \"cosmostation_wc_accounts_v1\",\n      \"cosmostation_wc_sign_tx_v1\",\n    ],\n    qrcodeModal: new CosmostationWCModal(),\n  });\n  await connector.createSession();\n  return connector;\n}","modal#Modal":"Use CosmostationModal when initializing WalletConnect to use DeepLink and QRCode connect.\nyarn add @cosmostation/wc-modal\nimport CosmostationWCModal from \"@cosmostation/wc-modal\";","event#Event":"By implementing connect/disconnect event, handle connect state event.\nconst connector = await connect();\nconnector.on(\"connect\", (error, payload) => {\n  if (error) {\n    setConnected(false);\n    throw error;\n  }\n  setConnected(true);\n});\nconnector.on(\"disconnect\", (error, payload) => {\n  setConnected(false);\n});"}},"/mobile/integration/walletconnect2":{"title":"WalletConnect 2.0","data":{"":"Cosmostation Mobile Wallet implement WalletConnect 2.0 specs.WalletConnect 2.0 Cosmos GuideWalletConnect 2.0 Example CodeWalletConnect 2.0 Example Page","connect#Connect":"import Client from \"@walletconnect/sign-client\";\nimport {\n  PairingTypes,\n  ProposalTypes,\n  SessionTypes,\n} from \"@walletconnect/types\";\nfunction App() {\n  const [client, setClient] = useState<Client>();\n  const [pairings, setPairings] = useState<PairingTypes.Struct[]>([]);\n  const [session, setSession] = useState<SessionTypes.Struct>();\n  const [chains, setChains] = useState<string[]>([]);\n  const [accounts, setAccounts] = useState<string[]>([]);\n  useEffect(() => {\n    if (client === undefined) {\n      createClient();\n    }\n  }, [client]);\n  const createClient = async () => {\n    try {\n      const _client = await Client.init({...});\n      setClient(_client);\n    } catch (err) {\n      throw err;\n    } finally {\n    }\n  };\n  async function connect() {\n    const modal = new Modal();\n    if (typeof client === \"undefined\") {\n      throw new Error(\"WalletConnect is not initialized\");\n    }\n    try {\n      const requiredNamespaces = getRequiredNamespaces();\n      const { uri, approval } = await client.connect({\n        pairingTopic: undefined,\n        requiredNamespaces: {\n          cosmos: {\n            methods: [\"cosmos_signDirect\", \"cosmos_signAmino\"],\n            chains: [\"cosmos:cosmoshub-4\"],\n            events: [],\n          },\n        },\n      });\n      if (uri) {\n        const standaloneChains = Object.values(requiredNamespaces)\n          .map((namespace) => namespace.chains)\n          .flat();\n        modal.open(uri, standaloneChains);\n      }\n      const session = await approval();\n      console.log(\"Established session:\", session);\n      await onSessionConnected(session);\n      setPairings(client.pairing.getAll({ active: true }));\n    } catch (e) {\n      console.error(e);\n    } finally {\n      modal.close();\n    }\n  }\n  const getRequiredNamespaces = (): ProposalTypes.RequiredNamespaces => {\n    return Object.fromEntries(\n      chains.map((namespace) => [\n        namespace,\n        {\n          methods: [\"cosmos_signDirect\", \"cosmos_signAmino\"],\n          chains: chains.filter((chain) => chain.startsWith(namespace)),\n          events: [],\n        },\n      ])\n    );\n  };\n  const onSessionConnected = useCallback(\n    async (_session: SessionTypes.Struct) => {\n      const allNamespaceAccounts = Object.values(_session.namespaces)\n        .map((namespace) => namespace.accounts)\n        .flat();\n      const allNamespaceChains = Object.keys(_session.namespaces);\n      setSession(_session);\n      setChains(allNamespaceChains);\n      setAccounts(allNamespaceAccounts);\n    },\n    []\n  );\n}"}},"/mobile/integration/cosmostation":{"title":"Cosmostation","data":{"":"If your project's dApp works well in Cosmostation Extension, it will work well in mobile too.\nCosmostation is designed to support both mobile and PC platforms in the same way as extensions.For more detailed explanation, please refer to the belows\nReact Hook\nVanilla\nReact Hook"}},"/extension/integration/cosmos/Deprecated/send-tx":{"title":"Send Transaction","data":{"":"Send transaction via Cosmostation Extension","code-using-cosmostationextension-client#Code using @cosmostation/extension-client":"import { SEND_TRANSACTION_MODE } from \"@cosmostation/extension-client/cosmos\";\n// ...\nconst response = await provider.sendTransaction(\n  \"cosmos\",\n  \"abc=\", // base64 string or Uint8Array\n  SEND_TRANSACTION_MODE.ASYNC /* SEND_TRANSACTION_MODE or one of [0, 1, 2, 3] */\n);","vanilla-code#Vanilla Code":"const response = await window.cosmostation.cosmos.request({\n  method: \"cos_sendTransaction\",\n  params: { chainName: \"cosmos\", txBytes: \"abc=\", mode: 0 },\n});","response#Response":"export type SendTransactionResponse = {\n  tx_response: SendTransaction;\n};\nexport type SendTransaction = {\n  code: number;\n  txhash: string;\n  raw_log?: unknown;\n  codespace?: unknown;\n  tx?: unknown;\n  log?: unknown;\n  info?: unknown;\n  height?: unknown;\n  gas_wanted?: unknown;\n  gas_used?: unknown;\n  events?: unknown;\n  data?: unknown;\n  timestamp?: unknown;\n};\nexport const SEND_TRANSACTION_MODE = {\n  UNSPECIFIED: 0,\n  BLOCK: 1,\n  SYNC: 2,\n  ASYNC: 3,\n};\n{\n  \"tx_response\": {\n    \"code\": 0,\n    \"codespace\": \"\",\n    \"data\": \"\",\n    \"events\": [],\n    \"gas_used\": \"0\",\n    \"gas_wanted\": \"0\",\n    \"height\": \"0\",\n    \"info\": \"\",\n    \"logs\": [],\n    \"raw_log\": \"[]\",\n    \"timestamp\": \"\",\n    \"tx\": null,\n    \"txhash\": \"\"\n  }\n}"}},"/mobile/integration/walletconnect/sign-tx":{"title":"Sign Transactions","data":{"":"Sign transaction using Cosmostation Mobile Wallet via WalletConnect.\nexport function getSignTxRequest(chainId, signer, signDoc) {\n  return {\n    id: payloadId(),\n    jsonrpc: \"2.0\",\n    method: \"cosmostation_wc_sign_tx_v1\",\n    params: [chainId, signer, signDoc],\n  };\n}\nconst signDoc = makeAminoSignDoc(\n  [message],\n  fee,\n  CHAIN_ID,\n  \"\",\n  accountNumber,\n  sequence\n);\nconst request = getSignAminoRequest(CHAIN_ID, address, signDoc);\nconnector\n  .sendCustomRequest(request)\n  .then((response) => {\n    const signed = _.get(response, \"0.signed\");\n    const signature = _.get(response, \"0.signature\");\n    return broadcastTx(signed, signature);\n  })\n  .then((result) => {\n    const code = _.get(result, \"code\");\n    if (code === 0) {\n      const txHash = _.get(result, \"txhash\");\n      console.log(txHash);\n    } else {\n      const rawLog = _.get(result, \"raw_log\");\n      console.error(rawLog);\n    }\n  });\ntype SignTxResponse = {\n  signed: StdSignDoc;\n  signature: { signature: string; pub_key: { type: string; value: string } };\n};"}},"/mobile/listing":{"title":"How to dApp listing?","data":{"":"For add your dapp to Mobile Wallet.Create a pull request from the link below.https://github.com/cosmostation/chainlist/blob/main/dapp/README.md"}},"/mintstation/module":{"title":"Building Modules","data":{"":"In this tutorial we will be going over building a module in Mintstation to show how easy it is to build on top of the Mintstation ecosystem. This module will be simple in nature but will show how to set up and connect a module to Mintstation and can be used as a starting point for more complex modules.","set-up#Set up":"git clone https://github.com/cosmostation/mintstation.git","defining-protocol-buffer-types#Defining Protocol Buffer Types":"The first step in building a new Mintstation Module is to define our Module's types. To do that we use Protocol Buffers which is a used for serializing structured data and generating code for multiple target languages, Protocol Buffers are also smaller than JSON & XML so sending data around the network will be less expensive. Learn More.Our Protobuf files will all live in proto/mintstation directory. We will create a new directory with the new module greet and add the following files in the proto/greet/v1beta1/ directory\ngenesis.proto\ngreet.proto\nquery.proto\ntx.proto","defining-the-greet-type#Defining The Greet Type":"Inside the proto/greet/v1beta1/greet.proto file lets define our greet type:\nsyntax = \"proto3\";\npackage  mintstation.greet.v1beta1;\nimport  \"cosmos_proto/cosmos.proto\";\nimport  \"gogoproto/gogo.proto\";\noption  go_package = \"github.com/cosmostation/mintstation/x/greet/types\";\nmessage Greet {\nstring owner = 1;\nstring id = 2;\nstring message = 3;\n}\nHere we are saying that we have a Greet type that will have an owner, an id and a message that will contain the greet string. Once we have that defined we are ready to set up a way to create this greet message and query it.","creating-a-new-greeting#Creating a new Greeting":"Inside the proto/greet/v1beta1/tx.proto file lets define our Msg Type:\nsyntax = \"proto3\";\npackage  mintstation.greet.v1beta1;\nimport  \"gogoproto/gogo.proto\";\nimport  \"cosmos_proto/cosmos.proto\";\noption  go_package = \"github.com/cosmostation/mintstation/x/greet/types\";\nservice  Msg {\n\trpc  CreateGreet(MsgCreateGreet) returns (MsgCreateGreetResponse);\n}\nmessage  MsgCreateGreet {\nstring message = 1;\nstring owner = 2;\n}\nmessage  MsgCreateGreetResponse {}\nNow that we have defined how to create a new Greeting let's finish up by setting up our queries to view a specific greeting or all of them.One thing to note here is that any state changing actions are transactions and for that reason we put them in our tx.proto files, we essentially said we are creating a new state changing message & defined the types for that message in our proto file, we will later add clients to trigger state change, which in our case will be adding a new message to our chain.","querying-greetings#Querying Greetings":"Code inside the proto/greet/v1beta1/query.proto :\nsyntax = \"proto3\";\npackage  mintstation.greet.v1beta1;\noption  go_package = \"github.com/cosmostation/mintstation/x/greet/types\";\nimport  \"gogoproto/gogo.proto\";\nimport  \"google/api/annotations.proto\";\nimport  \"cosmos/base/query/v1beta1/pagination.proto\";\nimport  \"cosmos_proto/cosmos.proto\";\nimport  \"mintstation/greet/v1beta1/greet.proto\";\nservice  Query {\n\trpc  Greet(QueryGetGreetRequest) returns (QueryGetGreetResponse) {\n\toption  (google.api.http).get = \"/mintstation/greet/v1beta1/greetings/{id}\";\n\t}\n\trpc  GreetAll(QueryAllGreetRequest) returns (QueryAllGreetResponse) {\n\toption  (google.api.http).get = \"/mintstation/swap/v1beta1/greetings\";\n\t}\n}\nmessage  QueryGetGreetRequest {\nstring id = 1;\n}\nmessage  QueryGetGreetResponse {\nGreet greeting = 1;\n}\nmessage  QueryAllGreetRequest {\ncosmos.base.query.v1beta1.PageRequest pagination = 1;\n}\nmessage  QueryAllGreetResponse {\nrepeated  Greet greetings = 1;\ncosmos.base.query.v1beta1.PageResponse pagination = 2;\n}\nOur query.proto now contains the types for our queries, we have defined a request type & a response type and those types will be returned once we trigger a query through the CLI, REST API, or Grpc. The response will follow the same structure regardless of the type of client initiating the request.We defined our query, tx, and greet proto files we finally need to set up the genesis file and then we are ready to generate these types. In the genesis file we will create a minimal genesis.proto for this tutorial to keep things simple.\nsyntax = \"proto3\";\npackage  mintstation.greet.v1beta1;\nimport  \"mintstation/greet/v1beta1/greet.proto\";\nimport  \"gogoproto/gogo.proto\";\nimport  \"google/protobuf/timestamp.proto\";\nimport  \"cosmos_proto/cosmos.proto\";\noption  go_package = \"github.com/cosmostation/mintstation/x/greet/types\";\n// our gensis state message will be empty for this tutorial\nmessage  GenesisState {}\nOnce all the files are filled in we are ready to generate our proto types. in the Mintstation Directory run make proto-gen  to generate the types, this will create a folder inside the x/greet and will contain the auto-generated proto types.","developing-our-greet-module#Developing Our Greet Module":"we have successfully set up our Proto files & generated them, we now have a x/greet directory generated, this is where we will write our module's code. For starters we will define our module's types in a new file inside x/greet/types/greet.go.","setting-up-constants--importing-packages#Setting up constants & importing packages":"Let's set up some basic constants for our module to help with routing, & fetching items from our store.\npackage  types\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"github.com/cosmos/cosmos-sdk/codec\"\n\t\"github.com/cosmos/cosmos-sdk/codec/types\"\n\tsdk  \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors  \"github.com/cosmos/cosmos-sdk/types/errors\"\n\t\"github.com/cosmos/cosmos-sdk/types/msgservice\"\n)\n// defined our module's constants such as name, routerkey\n// and prefixes for getting items from the store\nconst (\n\tModuleName =  \"greet\"\n\tStoreKey = ModuleName\n\tRouterKey = ModuleName\n\tQuerierRoute = ModuleName\n\tGreetKey =  \"greet-value-\"  // used for getting a greeting from our store\n\tGreetCountKey =  \"greet-count-\"  // used for getting count from out store\n\tQueryGetGreeting =  \"get-greeting\"  // used for legacy querier routing\n\tQueryListGreetings =  \"list-greetings\"// used for legacy querier routing\n)\n// heler function simply returns []byte out of a prefix string\nfunc  KeyPrefix(p string) []byte {\n\treturn []byte(p)\n}\n// returns default genesis state\nfunc  DefaultGenesisState() GenesisState {\n\treturn GenesisState{}\n}\n// validates genesis state\nfunc (gs GenesisState) Validate() error {\n\treturn  nil\n}","setting-up-our-msg-for-creating-a-new-greeting#Setting up our Msg for creating a new greeting":"Our MsgCreateGreet struct was created when we generated our Proto Types, we now need to use that struct to implement the sdk.Msg interface such that we can create new greetings. the first thing we will do is defined an unnamed variable with the _ syntax and have it implement the sdk.Msg type. This will help us catch unimplemented functions and guide us with syntax highlighting.\n// MsgCreateGreet we defined it here to get type checking\n//to make sure we are immplementing it correctly\nvar _ sdk.Msg =  &MsgCreateGreet{}\n// constructor for creating a new greeting\nfunc  NewMsgCreateGreet(owner string, message string) *MsgCreateGreet{\n\treturn  &MsgCreateGreet{\n\tOwner: owner,\n\tMessage: message,\n\t}\n}\n// does a quick stateless validation on our new greeting\nfunc (m *MsgCreateGreet) ValidateBasic() error {\n\t// ensures address is valid\n\tif _, err := sdk.AccAddressFromBech32(m.Owner); err !=  nil {\n\t\treturn sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, \"invalid owner address\", err)\n\t}\n\t// ensures the greeting is not empty\n\tif  len(strings.TrimSpace(m.Message)) ==  0 {\n\t\treturn fmt.Errorf(\"must provide a greeting message\")\n\t}\n\treturn  nil\n}\n// gets the signer of the new message which will be the owner of the greeting\nfunc (m *MsgCreateGreet) GetSigners() []sdk.AccAddress {\n\towner, err := sdk.AccAddressFromBech32(m.Owner);\n\tif err !=  nil {\n\t\tpanic(err)\n\t}\n\treturn []sdk.AccAddress{owner}\n}","registering-our-codec--interfaces#Registering our Codec & interfaces":"now that we have our MsgCreateGreet implement the sdk.Msg interface let's register our codec for marshaling/unmarshaling our greeting we will register both the deprecated legacy amino and the new Interface registry.\n// registers the marshal/unmarsahl for greating a new greeting for our legacy amino codec\nfunc  RegisterLegacyAminoCodec(cdc *codec.LegacyAmino){\n\tcdc.RegisterConcrete(&MsgCreateGreet{}, \"greet/CreateGreet\", nil)\n}\n// registers a module's interface types and their concrete implementations as proto.Message.\nfunc  RegisterInterfaces(registry types.InterfaceRegistry){\n\tregistry.RegisterImplementations((*sdk.Msg)(nil), &MsgCreateGreet{})\n\tmsgservice.RegisterMsgServiceDesc(registry, &_Msg_serviceDesc)\n}\nvar amino = codec.NewLegacyAmino()\nvar ModuleCdc = codec.NewAminoCodec(amino)","setting-up-a-basic-keeper#Setting up a basic Keeper":"we have finished up setting up our types, now it's time to implement our greet module's keeper, lets do that in a new folder & package named keeper, create x/greet/keeper/greet_keeper.go .","setting-up-the-keeper-struct--imports#Setting up the Keeper Struct & imports":"keepers are an abstraction over the state defined by a module, every module would have a keeper which would be used to access the state of that module, or if given access a keeper can also use other module's keepers by providing reference to the other module's keeper.\npackage  keeper\nimport (\n\t\"context\"\n\t\"strconv\"\n\t\"github.com/cosmos/cosmos-sdk/codec\"\n\t\"github.com/cosmos/cosmos-sdk/store/prefix\"\n\tsdk  \"github.com/cosmos/cosmos-sdk/types\"\n\tabci  \"github.com/tendermint/tendermint/abci/types\"\n\t\"github.com/cosmostation/mintstation/x/greet/types\"\n\tsdkerrors  \"github.com/cosmos/cosmos-sdk/types/errors\"\n)\ntype  Keeper  struct {\n\tcdc codec.Codec // used to marshall and unmarshall structs from & to []byte\n\tkey sdk.StoreKey // grant access to the store\n}\n// our constructor for creating a new Keeper for this module\nfunc  NewKeeper(c codec.Codec, k sdk.StoreKey) Keeper {\n\treturn Keeper{\n\tcdc: c,\n\tkey: k,\n\t}\n}","wiring-up-our-methods-for-handling-new-transactions--queries#Wiring up our methods for handling new transactions & queries":"Now that we have our Keeper Struct written, let's create some receiver functions on our keeper to handle adding a new greeting & looking up a greeting.\n// get greet count will be used for setting an Id when a new greeting is created\nfunc (k Keeper) GetGreetCount(ctx sdk.Context) int64 {\n\tstore := prefix.NewStore(ctx.KVStore(k.key), types.KeyPrefix(types.GreetCountKey))\n\tbyteKey := types.KeyPrefix(types.GreetCountKey)\n\tbz := store.Get(byteKey)\n\tif bz ==  nil {\n\t\treturn  0\n\t}\n\tcount, err := strconv.ParseInt(string(bz), 10, 64)\n\tif err !=  nil {\n\t\tpanic(\"cannot decode count\")\n\t}\n\treturn count\n}\n// sets the greet count\nfunc (k Keeper) SetGreetCount(ctx sdk.Context, count int64){\n\tstore := prefix.NewStore(ctx.KVStore(k.key), types.KeyPrefix(types.GreetCountKey))\n\tkey := types.KeyPrefix(types.GreetCountKey)\n\tvalue := []byte(strconv.FormatInt(count, 10))\n\tstore.Set(key, value)\n}\n// creates a new greeting\nfunc (k Keeper) CreateGreet(ctx sdk.Context, m types.MsgCreateGreet){\n\tcount := k.GetGreetCount(ctx)\n\tgreet := types.Greet{\n\tId: strconv.FormatInt(count, 10),\n\tOwner: m.Owner,\n\tMessage: m.Message,\n\t}\n\tstore := prefix.NewStore(ctx.KVStore(k.key), types.KeyPrefix(types.GreetKey))\n\tkey := types.KeyPrefix(types.GreetKey + greet.Id)\n\tvalue := k.cdc.MustMarshal(&greet)\n\tstore.Set(key, value)\n\tk.SetGreetCount(ctx, count +  1)\n}\n// gets a greeting from the store\nfunc (k Keeper) GetGreeting(ctx sdk.Context, key string) types.Greet {\n\tstore := prefix.NewStore(ctx.KVStore(k.key), types.KeyPrefix(types.GreetKey))\n\tvar Greet types.Greet\n\tk.cdc.Unmarshal(store.Get(types.KeyPrefix(types.GreetKey + key)), &Greet)\n\treturn Greet\n}\n// checks if a greeting exists by an id\nfunc (k Keeper) HasGreet(ctx sdk.Context, id string) bool {\n\tstore := prefix.NewStore(ctx.KVStore(k.key), types.KeyPrefix(types.GreetKey))\n\treturn store.Has(types.KeyPrefix(types.GreetKey + id))\n}\n// gets the owner of a greeting\nfunc (k Keeper) GetGreetOwner(ctx sdk.Context, key string) string {\n\treturn k.GetGreeting(ctx, key).Owner\n}\n// gets a list of all greetings in the store\nfunc (k Keeper) GetAllGreetings(ctx sdk.Context) (msgs []types.Greet){\n\tstore := prefix.NewStore(ctx.KVStore(k.key), types.KeyPrefix(types.GreetKey))\n\titerator := sdk.KVStorePrefixIterator(store, types.KeyPrefix(types.GreetKey))\n\tdefer iterator.Close()\n\tfor ; iterator.Valid(); iterator.Next() {\n\t\tvar msg types.Greet\n\t\tk.cdc.Unmarshal(iterator.Value(), &msg)\n\t\tmsgs =  append(msgs, msg)\n\t}\n\treturn\n}","handling-queries#Handling queries":"We have added methods for interacting with greetings such as creating or reading them, now let's set up our two query services so we can route them to the correct method, we will set up our legacy Querier & gRPC querier below the methods we defined above on our keeper.\nfunc (k Keeper) GreetAll(c context.Context, req *types.QueryAllGreetRequest) (*types.QueryAllGreetResponse, error){\n\tctx := sdk.UnwrapSDKContext(c)\n\tvar greetings []*types.Greet\n\tfor _, g :=  range k.GetAllGreetings(ctx) {\n\t\tvar greeting =  &g\n\t\tgreetings =  append(greetings,greeting)\n\t}\n\treturn  &types.QueryAllGreetResponse{Greetings: greetings, Pagination: nil}, nil\n}\nfunc (k Keeper) Greet(c context.Context, req *types.QueryGetGreetRequest) (*types.QueryGetGreetResponse, error){\n\tsdk.UnwrapSDKContext(c)\n\tvar greeting = k.GetGreeting(sdk.UnwrapSDKContext(c), req.Id)\n\treturn  &types.QueryGetGreetResponse{Greeting: &greeting}, nil\n}\n// LEGACY QUERIER will be deperacted but for the sake of competeness this is how to set it up\nfunc  NewQuerier(k Keeper, legacyQuerierCdc *codec.LegacyAmino) sdk.Querier {\n\treturn  func(ctx sdk.Context, path []string, req abci.RequestQuery) ([]byte, error) {\n\tswitch path[0] {\n\t\tcase types.QueryGetGreeting:\n\t\t\tvar getGreetRequest types.QueryGetGreetRequest\n\t\t\terr := legacyQuerierCdc.UnmarshalJSON(req.Data, &getGreetRequest)\n\t\t\tif err !=  nil {\n\t\t\t\treturn  nil, sdkerrors.Wrap(sdkerrors.ErrJSONUnmarshal, err.Error())\n\t\t\t}\n\t\t\tval := k.GetGreeting(ctx, getGreetRequest.GetId())\n\t\t\tbz, err := legacyQuerierCdc.MarshalJSON(val)\n\t\t\tif err !=  nil {\n\t\t\t\treturn  nil, sdkerrors.Wrap(sdkerrors.ErrJSONMarshal, err.Error())\n\t\t\t}\n\t\t\treturn bz, nil\n\t\tcase types.QueryListGreetings:\n\t\t\tval := k.GetAllGreetings(ctx)\n\t\t\tbz, err := codec.MarshalJSONIndent(legacyQuerierCdc, val)\n\t\t\tif err !=  nil {\n\t\t\t\treturn  nil, sdkerrors.Wrap(sdkerrors.ErrJSONMarshal, err.Error())\n\t\t\t}\n\t\t\treturn bz, nil\n\t\tdefault:\n\t\t\treturn  nil, sdkerrors.Wrapf(sdkerrors.ErrUnknownRequest, \"unknow request at %s query endpoint\", types.ModuleName)\n\t\t}\n\t}\n}","setting-up-a-command-to-create-a-new-greeting#Setting up a command to create a new greeting":"let's set up a way for clients to submit a new greeting & query existing greetings, we can do that with a CLI, REST, & gRPC clients. for this tutorial we will focus on setting up our CLI client. create x/greet/client/cli/tx.go.here We will define a command to create a new greeting:\npackage  cli\nimport (\n\t\"fmt\"\n\t\"github.com/cosmos/cosmos-sdk/client\"\n\t\"github.com/cosmos/cosmos-sdk/client/flags\"\n\t\"github.com/cosmos/cosmos-sdk/client/tx\"\n\t\"github.com/cosmostation/mintstation/x/greet/types\"\n\t\"github.com/spf13/cobra\"\n)\nfunc  GetTxCmd() *cobra.Command {\n\tcmd :=  &cobra.Command{\n\tUse: types.ModuleName,\n\tShort: fmt.Sprintf(\"%s transactions subcommands\", types.ModuleName),\n\tDisableFlagParsing: true,\n\tSuggestionsMinimumDistance: 2,\n\tRunE: client.ValidateCmd,\n\t}\n\tcmd.AddCommand(CmdCreateGreeting())\n\treturn cmd\n}\nfunc  CmdCreateGreeting() *cobra.Command {\n\tcmd:=  &cobra.Command{\n\tUse: \"create-greeting [message]\",\n\tShort: \"creates a new greetings\",\n\tArgs: cobra.ExactArgs(1),\n\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tmessage :=  string(args[0])\n\t\t\tclientCtx, err := client.GetClientTxContext(cmd)\n\t\t\tif err !=  nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tmsg := types.NewMsgCreateGreet(clientCtx.GetFromAddress().String(), string(message))\n\t\t\tif err := msg.ValidateBasic(); err !=  nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)\n\t\t},\n\t}\n\tflags.AddTxFlagsToCmd(cmd)\n\treturn cmd\n}","querying-greetings-1#Querying greetings":"We will now set up two different commands for querying, one will be to list all greetings & the other will be to get a greeting by it's id. inside x/greet/cli/query.go:\npackage  cli\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/cosmos/cosmos-sdk/client\"\n\t\"github.com/cosmos/cosmos-sdk/client/flags\"\n\t\"github.com/cosmostation/mintstation/x/greet/types\"\n\t\"github.com/spf13/cobra\"\n)\n// this is the parent query command for the greet module everytime we add a new command we will register it here\nfunc  GetQueryCmd(queryRoute string) *cobra.Command {\n// Group todos queries under a subcommand\n\tcmd :=  &cobra.Command{\n\t\tUse: types.ModuleName,\n\t\tShort: fmt.Sprintf(\"Querying commands for the %s module\", types.ModuleName),\n\t\tDisableFlagParsing: true,\n\t\tSuggestionsMinimumDistance: 2,\n\t\tRunE: client.ValidateCmd,\n\t}\n\tcmd.AddCommand(CmdListGreetings())\n\tcmd.AddCommand(CmdShowGreeting())\n\treturn cmd\n}\n// build the list greet command function\nfunc  CmdListGreetings() *cobra.Command {\n\tcmd :=  &cobra.Command{\n\tUse: \"list-greetings\",\n\tShort: \"list all greetings\",\n\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tclientCtx, err := client.GetClientTxContext(cmd)\n\t\t\tif err !=  nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tpageReq, err := client.ReadPageRequest(cmd.Flags())\n\t\t\tif err !=  nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tqueryClient := types.NewQueryClient(clientCtx)\n\t\t\tparams :=  &types.QueryAllGreetRequest{\n\t\t\tPagination: pageReq,\n\t\t\t}\n\t\t\tres, err := queryClient.GreetAll(context.Background(), params)\n\t\t\tif err !=  nil {\n\t\t\treturn err\n\t\t\t}\n\t\t\treturn clientCtx.PrintProto(res)\n\t\t},\n\t}\n\tflags.AddQueryFlagsToCmd(cmd)\n\treturn cmd\n}\n// build the show greet command function\nfunc  CmdShowGreeting() *cobra.Command {\n\tcmd :=  &cobra.Command{\n\tUse: \"get-greeting [id]\",\n\tShort: \"shows a greeting\",\n\tArgs: cobra.ExactArgs(1),\n\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tclientCtx, err := client.GetClientTxContext(cmd)\n\t\t\tif err !=  nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tqueryClient := types.NewQueryClient(clientCtx)\n\t\t\tparams :=  &types.QueryGetGreetRequest{\n\t\t\tId: args[0],\n\t\t\t}\n\t\t\tres, err := queryClient.Greet(context.Background(), params)\n\t\t\tif err !=  nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn clientCtx.PrintProto(res)\n\t\t},\n\t}\n\tflags.AddQueryFlagsToCmd(cmd)\n\treturn cmd\n}","setting-up-our-modules-package#Setting up our Module's package":"Now that we have all the basic functionality set up for our greet module, let's bring it all together and get our module ready to be used & tested, create a new file x/greet/module.go.Here we will start by implementing our AppModuleBasic && AppModule interfaces.\npackage  greet\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"github.com/cosmos/cosmos-sdk/client\"\n\t\"github.com/cosmos/cosmos-sdk/codec\"\n\tcdctypes  \"github.com/cosmos/cosmos-sdk/codec/types\"\n\tsdk  \"github.com/cosmos/cosmos-sdk/types\"\n\t\"github.com/cosmos/cosmos-sdk/types/module\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/grpc-ecosystem/grpc-gateway/runtime\"\n\t\"github.com/cosmostation/mintstation/x/greet/client/cli\"\n\t\"github.com/cosmostation/mintstation/x/greet/keeper\"\n\t\"github.com/cosmostation/mintstation/x/greet/types\"\n\t\"github.com/spf13/cobra\"\n\tabci  \"github.com/tendermint/tendermint/abci/types\"\n)\nvar (\n\t_ module.AppModule = AppModule{}\n\t_ module.AppModuleBasic = AppModuleBasic{}\n)\n/*\nThe AppModuleBasic interface defines the independent methods modules need to implement\nit follows this interface below\ntype AppModuleBasic interface {\n\tName() string\n\tRegisterLegacyAminoCodec(*codec.LegacyAmino)\n\tRegisterInterfaces(codectypes.InterfaceRegistry)\n\tDefaultGenesis(codec.JSONMarshaler) json.RawMessage\n\tValidateGenesis(codec.JSONMarshaler, client.TxEncodingConfig, json.RawMessage) error\n\t// client functionality\n\tRegisterRESTRoutes(client.Context, *mux.Router)\n\tRegisterGRPCRoutes(client.Context, *runtime.ServeMux)\n\tGetTxCmd() *cobra.Command\n\tGetQueryCmd() *cobra.Command\n}\n*/\ntype  AppModuleBasic  struct{}\n// Returns the name of the module as a string\nfunc (AppModuleBasic) Name() string {\n\treturn types.ModuleName\n}\nfunc (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage {\n\tgs := types.DefaultGenesisState()\n\treturn cdc.MustMarshalJSON(&gs)\n}\nfunc (AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error {\n\treturn  nil\n}\n// Registers the amino codec for the module, which is used to marshal\n// and unmarshal structs to/from []byte in order to persist them in the module's KVStore.\nfunc (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino){\n\ttypes.RegisterLegacyAminoCodec(cdc)\n}\n// Registers a module's interface types and their concrete implementations as proto.Message\nfunc (AppModuleBasic) RegisterInterfaces(registry cdctypes.InterfaceRegistry) {\n\ttypes.RegisterInterfaces(registry)\n}\n// Registers gRPC routes for the module.\nfunc (a AppModuleBasic) RegisterGRPCGatewayRoutes(clientCtx client.Context, mux *runtime.ServeMux) {\n\tif err := types.RegisterQueryHandlerClient(context.Background(), mux, types.NewQueryClient(clientCtx)); err !=  nil {\n\t\tpanic(err)\n\t}\n}\n// Registers the REST routes for the module. These routes will be used to map REST request to the module in order to process them\nfunc (a AppModuleBasic) RegisterRESTRoutes(clientCtx client.Context, rtr *mux.Router) { }\n// Returns the root Tx command for the module. The subcommands of this root command are used by end-users\n// to generate new transactions containing messages defined in the module\nfunc (AppModuleBasic) GetTxCmd() *cobra.Command {\n\treturn cli.GetTxCmd()\n}\n// Return the root query command for the module. The subcommands of this root command are used by end-users\n// to generate new queries to the subset of the state defined by the module.\nfunc (AppModuleBasic) GetQueryCmd() *cobra.Command {\n\treturn cli.GetQueryCmd(types.StoreKey)\n}\n// -------------------------------------APPMODULE BELOW------------------------------------------------- //\n/*\nThe AppModule interface defines the inter-dependent methods that modules need to implement\nfollows the interface below\n\ttype AppModule interface {\n\t\tAppModuleGenesis\n\t\t// registers\n\t\tRegisterInvariants(sdk.InvariantRegistry)\n\t\t// routes\n\t\tRoute() sdk.Route\n\t\t// Deprecated: use RegisterServices\n\t\tQuerierRoute() string\n\t\t// Deprecated: use RegisterServices\n\t\tLegacyQuerierHandler(*codec.LegacyAmino) sdk.Querier\n\t\t// RegisterServices allows a module to register services\n\t\tRegisterServices(Configurator)\n\t\t// ABCI\n\t\tBeginBlock(sdk.Context, abci.RequestBeginBlock)\n\t\tEndBlock(sdk.Context, abci.RequestEndBlock) []abci.ValidatorUpdate\n\t}\n*/\ntype  AppModule  struct{\n\tAppModuleBasic\n\tkeeper keeper.Keeper\n}\n// constructor\nfunc  NewAppModule(keeper keeper.Keeper) AppModule {\n\treturn AppModule{\n\t\tAppModuleBasic: AppModuleBasic{},\n\t\tkeeper: keeper,\n\t}\n}\n// Returns the route for messages to be routed to the module by BaseApp.\nfunc (am AppModule) Name() string {\n\treturn am.AppModuleBasic.Name()\n}\n// registers the invariants of the module. If an invariant deviates from its predicted value,\n// the InvariantRegistry triggers appropriate logic (most often the chain will be halted).\nfunc (AppModule) RegisterInvariants(ir sdk.InvariantRegistry) { }\n// Returns the route for messages to be routed to the module by BaseApp.\nfunc (AppModule) Route() sdk.Route {\n\treturn sdk.Route{}\n}\n// Returns the name of the module's query route, for queries to be routes to the module by BaseApp.deprecated\nfunc (AppModule) QuerierRoute() string {\n\treturn types.QuerierRoute\n}\n// Returns a querier given the query path, in order to process the query.\nfunc (am AppModule) LegacyQuerierHandler(legacyQuerierCdc *codec.LegacyAmino) sdk.Querier {\n\treturn keeper.NewQuerier(am.keeper, legacyQuerierCdc)\n}\nfunc (AppModule) ConsensusVersion() uint64 {\n\treturn  1\n}\n// Allows a module to register services.\nfunc (am AppModule) RegisterServices(cfg module.Configurator) {\n\ttypes.RegisterMsgServer(cfg.MsgServer(), NewMsgServerImpl(am.keeper))\n\ttypes.RegisterQueryServer(cfg.QueryServer(), am.keeper)\n}\nfunc (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, gs json.RawMessage) []abci.ValidatorUpdate {\n\treturn []abci.ValidatorUpdate{}\n}\nfunc (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage {\n\tgs := types.DefaultGenesisState()\n\treturn cdc.MustMarshalJSON(&gs)\n}\nfunc (am AppModule) BeginBlock(_ sdk.Context, _ abci.RequestBeginBlock) { }\nfunc (am AppModule) EndBlock(_ sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate {\n\treturn []abci.ValidatorUpdate{}\n}\n// ----------------------------------MSGSERVER REGISTER------------------------//\nvar _ types.MsgServer = msgServer{}\ntype  msgServer  struct {\n\tkeeper keeper.Keeper\n}\nfunc (m msgServer) CreateGreet(c context.Context, msg *types.MsgCreateGreet) (*types.MsgCreateGreetResponse, error) {\n\tctx := sdk.UnwrapSDKContext(c)\n\tm.keeper.CreateGreet(ctx, types.MsgCreateGreet{Owner: msg.Owner, Message: msg.Message})\n\treturn  &types.MsgCreateGreetResponse{}, nil\n}\nfunc  NewMsgServerImpl(keeper keeper.Keeper) types.MsgServer {\n\treturn  &msgServer{keeper: keeper}\n}","hooking-up-our-module-inside-appgo#Hooking up our module inside App.go":"inside app/app.go start off importing the greet module, it's types & keeper packages and add them to the following places:\nmodule.NewBasicManager() add greet.AppModuleBasic{}\ntype App struct {} add greetkeeper.Keeper\nsdk.NewKVStoreKeys() inside NewApp func add greettypes.StoreKey\ninside NewApp func add app.greetKeeper = greetKeeper.NewKeeper() and add arguments appCodec & keys[greettypes.StoreKey]\ninside NewApp find where we define app.mm & add greet.NewAppModule(app.greetKeeper),\nfinally add the greet module's name to SetOrderBeginBlockers, SetOrderEndBlockers && SetOrderInitGenesis","testing-our-new-module#Testing our new Module":"inside the root of our directory run docker build -t mintstation/mintstation:tutorial-demo .\nfind the directory for kvtool and open in your favorite code editor\nrun kvtool testnet gen-config mintstation --mintstation.configTemplate upgrade-v44 which will create a bunch of files inside full_configs/generated\nopen up the two docker-compose.yaml files the one inside generated & the one inside generated/mintstation and change the image to point to mintstation/mintstation:tutorial-demo this will point to the local image we just built\nchange into the full_configs/generated directory and run docker compose up -d\nnow run docker compose exec mintstationnode bash to bash into our mintstation cli inside the running container\nWe should now have access to our greet commands that we defined first we will test creating a new greeting, for that we will run the following command:mintstationd tx greet create-greeting \"hello world from mintstation chain\" --from whalenow let's test to see if the greeting message is able to be queried:mintstationd q greet list-greetingsWe should see something like this below:\ngreetings:\n- id: \"0\"\n  message: hello world from mintstation chain\n  owner: \npagination: null\nNow let's test if we can query the greeting by it's id which in our case will be \"0\", run the following:mintstationd q greet get-greeting 0We should see:\ngreeting:\n  id: \"0\"\n  message: hello world from mintstation chain\n  owner: "}}}